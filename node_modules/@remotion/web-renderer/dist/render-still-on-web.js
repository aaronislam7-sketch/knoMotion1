import { jsx as _jsx } from "react/jsx-runtime";
import ReactDOM from 'react-dom/client';
import { Internals } from 'remotion';
import { compose } from './compose';
import { findCanvasElements } from './find-canvas-elements';
import { findSvgElements } from './find-svg-elements';
import { waitForReady } from './wait-for-ready';
const COMP_ID = 'markup';
const internalRenderStillOnWeb = async ({ Component, width, height, fps, durationInFrames, frame, delayRenderTimeoutInMilliseconds, logLevel, }) => {
    const div = document.createElement('div');
    // Match same behavior as renderEntry.tsx
    div.style.display = 'flex';
    div.style.backgroundColor = 'transparent';
    div.style.position = 'fixed';
    div.style.width = `${width}px`;
    div.style.height = `${height}px`;
    div.style.zIndex = '-9999';
    document.body.appendChild(div);
    if (!ReactDOM.createRoot) {
        throw new Error('@remotion/web-renderer requires React 18 or higher');
    }
    // TODO: Env variables
    // TODO: Input Props
    // TODO: Default props
    // TODO: calculateMetadata()
    // TODO: getRemotionEnvironment()
    // TODO: delayRender()
    // TODO: Video config
    // TODO: window.remotion_isPlayer
    const root = ReactDOM.createRoot(div);
    const delayRenderScope = {
        remotion_renderReady: true,
        remotion_delayRenderTimeouts: {},
        remotion_puppeteerTimeout: delayRenderTimeoutInMilliseconds,
        remotion_attempt: 0,
    };
    root.render(_jsx(Internals.RemotionEnvironmentContext, { value: {
            isStudio: false,
            isRendering: true,
            isPlayer: false,
            isReadOnlyStudio: false,
            isClientSideRendering: true,
        }, children: _jsx(Internals.DelayRenderContextType.Provider, { value: delayRenderScope, children: _jsx(Internals.CompositionManagerProvider, { initialCanvasContent: {
                    type: 'composition',
                    compositionId: COMP_ID,
                }, onlyRenderComposition: null, 
                // TODO: Hardcoded
                currentCompositionMetadata: {
                    // TODO: Empty
                    props: {},
                    durationInFrames,
                    fps,
                    height,
                    width,
                    defaultCodec: null,
                    defaultOutName: null,
                    defaultVideoImageFormat: null,
                    defaultPixelFormat: null,
                    defaultProResProfile: null,
                }, initialCompositions: [
                    {
                        id: COMP_ID,
                        component: Component,
                        nonce: 0,
                        // TODO: Do we need to allow to set this?
                        defaultProps: undefined,
                        folderName: null,
                        parentFolderName: null,
                        schema: null,
                        calculateMetadata: null,
                        durationInFrames,
                        fps,
                        height,
                        width,
                    },
                ], children: _jsx(Internals.RemotionRoot
                // TODO: Hardcoded
                , { 
                    // TODO: Hardcoded
                    audioEnabled: false, 
                    // TODO: Hardcoded
                    videoEnabled: true, logLevel: logLevel, numberOfAudioTags: 0, 
                    // TODO: Hardcoded
                    audioLatencyHint: "interactive", frameState: {
                        [COMP_ID]: frame,
                    }, children: _jsx(Internals.CanUseRemotionHooks, { value: true, children: _jsx(Component, {}) }) }) }) }) }));
    // TODO: Scope cancelRender()
    await waitForReady(delayRenderTimeoutInMilliseconds, delayRenderScope);
    const canvasElements = findCanvasElements(div);
    const svgElements = findSvgElements(div);
    const composed = await compose({
        composables: [...canvasElements, ...svgElements],
        width,
        height,
    });
    const imageData = await composed.convertToBlob({
        type: 'image/png',
    });
    root.unmount();
    div.remove();
    return imageData;
};
export const renderStillOnWeb = (options) => {
    var _a, _b;
    return internalRenderStillOnWeb({
        ...options,
        delayRenderTimeoutInMilliseconds: (_a = options.delayRenderTimeoutInMilliseconds) !== null && _a !== void 0 ? _a : 30000,
        logLevel: (_b = options.logLevel) !== null && _b !== void 0 ? _b : 'info',
    });
};
