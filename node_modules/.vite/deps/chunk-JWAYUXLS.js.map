{
  "version": 3,
  "sources": ["../../@remotion/paths/dist/esm/index.mjs", "../../@remotion/shapes/dist/esm/index.mjs"],
  "sourcesContent": ["// src/cut-instruction.ts\nvar cutLInstruction = ({\n  instruction,\n  lastPoint,\n  progress\n}) => {\n  const x = lastPoint.x + (instruction.x - lastPoint.x) * progress;\n  const y = lastPoint.y + (instruction.y - lastPoint.y) * progress;\n  return {\n    type: \"L\",\n    x,\n    y\n  };\n};\nfunction interpolatePoint(pA, pB, factor) {\n  return {\n    x: pA.x + (pB.x - pA.x) * factor,\n    y: pA.y + (pB.y - pA.y) * factor\n  };\n}\nfunction cutCInstruction({\n  progress,\n  lastPoint,\n  instruction\n}) {\n  const u = progress;\n  const p0 = { x: lastPoint.x, y: lastPoint.y };\n  const p1 = { x: instruction.cp1x, y: instruction.cp1y };\n  const p2 = { x: instruction.cp2x, y: instruction.cp2y };\n  const p3 = { x: instruction.x, y: instruction.y };\n  const p01 = interpolatePoint(p0, p1, u);\n  const p12 = interpolatePoint(p1, p2, u);\n  const p23 = interpolatePoint(p2, p3, u);\n  const p012 = interpolatePoint(p01, p12, u);\n  const p123 = interpolatePoint(p12, p23, u);\n  const p0123 = interpolatePoint(p012, p123, u);\n  return {\n    type: \"C\",\n    cp1x: p01.x,\n    cp1y: p01.y,\n    cp2x: p012.x,\n    cp2y: p012.y,\n    x: p0123.x,\n    y: p0123.y\n  };\n}\nvar cutInstruction = ({\n  instruction,\n  lastPoint,\n  progress\n}) => {\n  if (instruction.type === \"M\") {\n    return instruction;\n  }\n  if (instruction.type === \"L\") {\n    return cutLInstruction({ instruction, lastPoint, progress });\n  }\n  if (instruction.type === \"C\") {\n    return cutCInstruction({ instruction, lastPoint, progress });\n  }\n  if (instruction.type === \"Z\") {\n    return instruction;\n  }\n  throw new TypeError(`${instruction.type} is not supported.`);\n};\n\n// src/helpers/bezier-values.ts\nvar tValues = [\n  [],\n  [],\n  [\n    -0.5773502691896257,\n    0.5773502691896257\n  ],\n  [\n    0,\n    -0.7745966692414834,\n    0.7745966692414834\n  ],\n  [\n    -0.33998104358485626,\n    0.33998104358485626,\n    -0.8611363115940526,\n    0.8611363115940526\n  ],\n  [\n    0,\n    -0.5384693101056831,\n    0.5384693101056831,\n    -0.906179845938664,\n    0.906179845938664\n  ],\n  [\n    0.6612093864662645,\n    -0.6612093864662645,\n    -0.2386191860831969,\n    0.2386191860831969,\n    -0.932469514203152,\n    0.932469514203152\n  ],\n  [\n    0,\n    0.4058451513773972,\n    -0.4058451513773972,\n    -0.7415311855993945,\n    0.7415311855993945,\n    -0.9491079123427585,\n    0.9491079123427585\n  ],\n  [\n    -0.1834346424956498,\n    0.1834346424956498,\n    -0.525532409916329,\n    0.525532409916329,\n    -0.7966664774136267,\n    0.7966664774136267,\n    -0.9602898564975363,\n    0.9602898564975363\n  ],\n  [\n    0,\n    -0.8360311073266358,\n    0.8360311073266358,\n    -0.9681602395076261,\n    0.9681602395076261,\n    -0.3242534234038089,\n    0.3242534234038089,\n    -0.6133714327005904,\n    0.6133714327005904\n  ],\n  [\n    -0.14887433898163122,\n    0.14887433898163122,\n    -0.4333953941292472,\n    0.4333953941292472,\n    -0.6794095682990244,\n    0.6794095682990244,\n    -0.8650633666889845,\n    0.8650633666889845,\n    -0.9739065285171717,\n    0.9739065285171717\n  ],\n  [\n    0,\n    -0.26954315595234496,\n    0.26954315595234496,\n    -0.5190961292068118,\n    0.5190961292068118,\n    -0.7301520055740494,\n    0.7301520055740494,\n    -0.8870625997680953,\n    0.8870625997680953,\n    -0.978228658146057,\n    0.978228658146057\n  ],\n  [\n    -0.1252334085114689,\n    0.1252334085114689,\n    -0.3678314989981802,\n    0.3678314989981802,\n    -0.5873179542866175,\n    0.5873179542866175,\n    -0.7699026741943047,\n    0.7699026741943047,\n    -0.9041172563704749,\n    0.9041172563704749,\n    -0.9815606342467192,\n    0.9815606342467192\n  ],\n  [\n    0,\n    -0.2304583159551348,\n    0.2304583159551348,\n    -0.44849275103644687,\n    0.44849275103644687,\n    -0.6423493394403402,\n    0.6423493394403402,\n    -0.8015780907333099,\n    0.8015780907333099,\n    -0.9175983992229779,\n    0.9175983992229779,\n    -0.9841830547185881,\n    0.9841830547185881\n  ],\n  [\n    -0.10805494870734367,\n    0.10805494870734367,\n    -0.31911236892788974,\n    0.31911236892788974,\n    -0.5152486363581541,\n    0.5152486363581541,\n    -0.6872929048116855,\n    0.6872929048116855,\n    -0.827201315069765,\n    0.827201315069765,\n    -0.9284348836635735,\n    0.9284348836635735,\n    -0.9862838086968123,\n    0.9862838086968123\n  ],\n  [\n    0,\n    -0.20119409399743451,\n    0.20119409399743451,\n    -0.3941513470775634,\n    0.3941513470775634,\n    -0.5709721726085388,\n    0.5709721726085388,\n    -0.7244177313601701,\n    0.7244177313601701,\n    -0.8482065834104272,\n    0.8482065834104272,\n    -0.937273392400706,\n    0.937273392400706,\n    -0.9879925180204854,\n    0.9879925180204854\n  ],\n  [\n    -0.09501250983763744,\n    0.09501250983763744,\n    -0.2816035507792589,\n    0.2816035507792589,\n    -0.45801677765722737,\n    0.45801677765722737,\n    -0.6178762444026438,\n    0.6178762444026438,\n    -0.755404408355003,\n    0.755404408355003,\n    -0.8656312023878318,\n    0.8656312023878318,\n    -0.9445750230732326,\n    0.9445750230732326,\n    -0.9894009349916499,\n    0.9894009349916499\n  ],\n  [\n    0,\n    -0.17848418149584785,\n    0.17848418149584785,\n    -0.3512317634538763,\n    0.3512317634538763,\n    -0.5126905370864769,\n    0.5126905370864769,\n    -0.6576711592166907,\n    0.6576711592166907,\n    -0.7815140038968014,\n    0.7815140038968014,\n    -0.8802391537269859,\n    0.8802391537269859,\n    -0.9506755217687678,\n    0.9506755217687678,\n    -0.9905754753144174,\n    0.9905754753144174\n  ],\n  [\n    -0.0847750130417353,\n    0.0847750130417353,\n    -0.2518862256915055,\n    0.2518862256915055,\n    -0.41175116146284263,\n    0.41175116146284263,\n    -0.5597708310739475,\n    0.5597708310739475,\n    -0.6916870430603532,\n    0.6916870430603532,\n    -0.8037049589725231,\n    0.8037049589725231,\n    -0.8926024664975557,\n    0.8926024664975557,\n    -0.9558239495713977,\n    0.9558239495713977,\n    -0.9915651684209309,\n    0.9915651684209309\n  ],\n  [\n    0,\n    -0.16035864564022537,\n    0.16035864564022537,\n    -0.31656409996362983,\n    0.31656409996362983,\n    -0.46457074137596094,\n    0.46457074137596094,\n    -0.600545304661681,\n    0.600545304661681,\n    -0.7209661773352294,\n    0.7209661773352294,\n    -0.8227146565371428,\n    0.8227146565371428,\n    -0.9031559036148179,\n    0.9031559036148179,\n    -0.96020815213483,\n    0.96020815213483,\n    -0.9924068438435844,\n    0.9924068438435844\n  ],\n  [\n    -0.07652652113349734,\n    0.07652652113349734,\n    -0.22778585114164507,\n    0.22778585114164507,\n    -0.37370608871541955,\n    0.37370608871541955,\n    -0.5108670019508271,\n    0.5108670019508271,\n    -0.636053680726515,\n    0.636053680726515,\n    -0.7463319064601508,\n    0.7463319064601508,\n    -0.8391169718222188,\n    0.8391169718222188,\n    -0.912234428251326,\n    0.912234428251326,\n    -0.9639719272779138,\n    0.9639719272779138,\n    -0.9931285991850949,\n    0.9931285991850949\n  ],\n  [\n    0,\n    -0.1455618541608951,\n    0.1455618541608951,\n    -0.2880213168024011,\n    0.2880213168024011,\n    -0.4243421202074388,\n    0.4243421202074388,\n    -0.5516188358872198,\n    0.5516188358872198,\n    -0.6671388041974123,\n    0.6671388041974123,\n    -0.7684399634756779,\n    0.7684399634756779,\n    -0.8533633645833173,\n    0.8533633645833173,\n    -0.9200993341504008,\n    0.9200993341504008,\n    -0.9672268385663063,\n    0.9672268385663063,\n    -0.9937521706203895,\n    0.9937521706203895\n  ],\n  [\n    -0.06973927331972223,\n    0.06973927331972223,\n    -0.20786042668822127,\n    0.20786042668822127,\n    -0.34193582089208424,\n    0.34193582089208424,\n    -0.469355837986757,\n    0.469355837986757,\n    -0.5876404035069116,\n    0.5876404035069116,\n    -0.6944872631866827,\n    0.6944872631866827,\n    -0.7878168059792081,\n    0.7878168059792081,\n    -0.8658125777203002,\n    0.8658125777203002,\n    -0.926956772187174,\n    0.926956772187174,\n    -0.9700604978354287,\n    0.9700604978354287,\n    -0.9942945854823992,\n    0.9942945854823992\n  ],\n  [\n    0,\n    -0.1332568242984661,\n    0.1332568242984661,\n    -0.26413568097034495,\n    0.26413568097034495,\n    -0.3903010380302908,\n    0.3903010380302908,\n    -0.5095014778460075,\n    0.5095014778460075,\n    -0.6196098757636461,\n    0.6196098757636461,\n    -0.7186613631319502,\n    0.7186613631319502,\n    -0.8048884016188399,\n    0.8048884016188399,\n    -0.8767523582704416,\n    0.8767523582704416,\n    -0.9329710868260161,\n    0.9329710868260161,\n    -0.9725424712181152,\n    0.9725424712181152,\n    -0.9947693349975522,\n    0.9947693349975522\n  ],\n  [\n    -0.06405689286260563,\n    0.06405689286260563,\n    -0.1911188674736163,\n    0.1911188674736163,\n    -0.3150426796961634,\n    0.3150426796961634,\n    -0.4337935076260451,\n    0.4337935076260451,\n    -0.5454214713888396,\n    0.5454214713888396,\n    -0.6480936519369755,\n    0.6480936519369755,\n    -0.7401241915785544,\n    0.7401241915785544,\n    -0.820001985973903,\n    0.820001985973903,\n    -0.8864155270044011,\n    0.8864155270044011,\n    -0.9382745520027328,\n    0.9382745520027328,\n    -0.9747285559713095,\n    0.9747285559713095,\n    -0.9951872199970213,\n    0.9951872199970213\n  ]\n];\nvar cValues = [\n  [],\n  [],\n  [1, 1],\n  [\n    0.8888888888888888,\n    0.5555555555555556,\n    0.5555555555555556\n  ],\n  [\n    0.6521451548625461,\n    0.6521451548625461,\n    0.34785484513745385,\n    0.34785484513745385\n  ],\n  [\n    0.5688888888888889,\n    0.47862867049936647,\n    0.47862867049936647,\n    0.23692688505618908,\n    0.23692688505618908\n  ],\n  [\n    0.3607615730481386,\n    0.3607615730481386,\n    0.46791393457269104,\n    0.46791393457269104,\n    0.17132449237917036,\n    0.17132449237917036\n  ],\n  [\n    0.4179591836734694,\n    0.3818300505051189,\n    0.3818300505051189,\n    0.27970539148927664,\n    0.27970539148927664,\n    0.1294849661688697,\n    0.1294849661688697\n  ],\n  [\n    0.362683783378362,\n    0.362683783378362,\n    0.31370664587788727,\n    0.31370664587788727,\n    0.22238103445337448,\n    0.22238103445337448,\n    0.10122853629037626,\n    0.10122853629037626\n  ],\n  [\n    0.3302393550012598,\n    0.1806481606948574,\n    0.1806481606948574,\n    0.08127438836157441,\n    0.08127438836157441,\n    0.31234707704000286,\n    0.31234707704000286,\n    0.26061069640293544,\n    0.26061069640293544\n  ],\n  [\n    0.29552422471475287,\n    0.29552422471475287,\n    0.26926671930999635,\n    0.26926671930999635,\n    0.21908636251598204,\n    0.21908636251598204,\n    0.1494513491505806,\n    0.1494513491505806,\n    0.06667134430868814,\n    0.06667134430868814\n  ],\n  [\n    0.2729250867779006,\n    0.26280454451024665,\n    0.26280454451024665,\n    0.23319376459199048,\n    0.23319376459199048,\n    0.18629021092773426,\n    0.18629021092773426,\n    0.1255803694649046,\n    0.1255803694649046,\n    0.05566856711617366,\n    0.05566856711617366\n  ],\n  [\n    0.24914704581340277,\n    0.24914704581340277,\n    0.2334925365383548,\n    0.2334925365383548,\n    0.20316742672306592,\n    0.20316742672306592,\n    0.16007832854334622,\n    0.16007832854334622,\n    0.10693932599531843,\n    0.10693932599531843,\n    0.04717533638651183,\n    0.04717533638651183\n  ],\n  [\n    0.2325515532308739,\n    0.22628318026289723,\n    0.22628318026289723,\n    0.2078160475368885,\n    0.2078160475368885,\n    0.17814598076194574,\n    0.17814598076194574,\n    0.13887351021978725,\n    0.13887351021978725,\n    0.09212149983772845,\n    0.09212149983772845,\n    0.04048400476531588,\n    0.04048400476531588\n  ],\n  [\n    0.2152638534631578,\n    0.2152638534631578,\n    0.2051984637212956,\n    0.2051984637212956,\n    0.18553839747793782,\n    0.18553839747793782,\n    0.15720316715819355,\n    0.15720316715819355,\n    0.12151857068790319,\n    0.12151857068790319,\n    0.08015808715976021,\n    0.08015808715976021,\n    0.03511946033175186,\n    0.03511946033175186\n  ],\n  [\n    0.2025782419255613,\n    0.19843148532711158,\n    0.19843148532711158,\n    0.1861610000155622,\n    0.1861610000155622,\n    0.16626920581699392,\n    0.16626920581699392,\n    0.13957067792615432,\n    0.13957067792615432,\n    0.10715922046717194,\n    0.10715922046717194,\n    0.07036604748810812,\n    0.07036604748810812,\n    0.03075324199611727,\n    0.03075324199611727\n  ],\n  [\n    0.1894506104550685,\n    0.1894506104550685,\n    0.18260341504492358,\n    0.18260341504492358,\n    0.16915651939500254,\n    0.16915651939500254,\n    0.14959598881657674,\n    0.14959598881657674,\n    0.12462897125553388,\n    0.12462897125553388,\n    0.09515851168249279,\n    0.09515851168249279,\n    0.062253523938647894,\n    0.062253523938647894,\n    0.027152459411754096,\n    0.027152459411754096\n  ],\n  [\n    0.17944647035620653,\n    0.17656270536699264,\n    0.17656270536699264,\n    0.16800410215645004,\n    0.16800410215645004,\n    0.15404576107681028,\n    0.15404576107681028,\n    0.13513636846852548,\n    0.13513636846852548,\n    0.11188384719340397,\n    0.11188384719340397,\n    0.08503614831717918,\n    0.08503614831717918,\n    0.0554595293739872,\n    0.0554595293739872,\n    0.02414830286854793,\n    0.02414830286854793\n  ],\n  [\n    0.1691423829631436,\n    0.1691423829631436,\n    0.16427648374583273,\n    0.16427648374583273,\n    0.15468467512626524,\n    0.15468467512626524,\n    0.14064291467065065,\n    0.14064291467065065,\n    0.12255520671147846,\n    0.12255520671147846,\n    0.10094204410628717,\n    0.10094204410628717,\n    0.07642573025488905,\n    0.07642573025488905,\n    0.0497145488949698,\n    0.0497145488949698,\n    0.02161601352648331,\n    0.02161601352648331\n  ],\n  [\n    0.1610544498487837,\n    0.15896884339395434,\n    0.15896884339395434,\n    0.15276604206585967,\n    0.15276604206585967,\n    0.1426067021736066,\n    0.1426067021736066,\n    0.12875396253933621,\n    0.12875396253933621,\n    0.11156664554733399,\n    0.11156664554733399,\n    0.09149002162245,\n    0.09149002162245,\n    0.06904454273764123,\n    0.06904454273764123,\n    0.0448142267656996,\n    0.0448142267656996,\n    0.019461788229726478,\n    0.019461788229726478\n  ],\n  [\n    0.15275338713072584,\n    0.15275338713072584,\n    0.14917298647260374,\n    0.14917298647260374,\n    0.14209610931838204,\n    0.14209610931838204,\n    0.13168863844917664,\n    0.13168863844917664,\n    0.11819453196151841,\n    0.11819453196151841,\n    0.10193011981724044,\n    0.10193011981724044,\n    0.08327674157670475,\n    0.08327674157670475,\n    0.06267204833410907,\n    0.06267204833410907,\n    0.04060142980038694,\n    0.04060142980038694,\n    0.017614007139152118,\n    0.017614007139152118\n  ],\n  [\n    0.14608113364969041,\n    0.14452440398997005,\n    0.14452440398997005,\n    0.13988739479107315,\n    0.13988739479107315,\n    0.13226893863333747,\n    0.13226893863333747,\n    0.12183141605372853,\n    0.12183141605372853,\n    0.10879729916714838,\n    0.10879729916714838,\n    0.09344442345603386,\n    0.09344442345603386,\n    0.0761001136283793,\n    0.0761001136283793,\n    0.057134425426857205,\n    0.057134425426857205,\n    0.036953789770852494,\n    0.036953789770852494,\n    0.016017228257774335,\n    0.016017228257774335\n  ],\n  [\n    0.13925187285563198,\n    0.13925187285563198,\n    0.13654149834601517,\n    0.13654149834601517,\n    0.13117350478706238,\n    0.13117350478706238,\n    0.12325237681051242,\n    0.12325237681051242,\n    0.11293229608053922,\n    0.11293229608053922,\n    0.10041414444288096,\n    0.10041414444288096,\n    0.08594160621706773,\n    0.08594160621706773,\n    0.06979646842452049,\n    0.06979646842452049,\n    0.052293335152683286,\n    0.052293335152683286,\n    0.03377490158481415,\n    0.03377490158481415,\n    0.0146279952982722,\n    0.0146279952982722\n  ],\n  [\n    0.13365457218610619,\n    0.1324620394046966,\n    0.1324620394046966,\n    0.12890572218808216,\n    0.12890572218808216,\n    0.12304908430672953,\n    0.12304908430672953,\n    0.11499664022241136,\n    0.11499664022241136,\n    0.10489209146454141,\n    0.10489209146454141,\n    0.09291576606003515,\n    0.09291576606003515,\n    0.07928141177671895,\n    0.07928141177671895,\n    0.06423242140852585,\n    0.06423242140852585,\n    0.04803767173108467,\n    0.04803767173108467,\n    0.030988005856979445,\n    0.030988005856979445,\n    0.013411859487141771,\n    0.013411859487141771\n  ],\n  [\n    0.12793819534675216,\n    0.12793819534675216,\n    0.1258374563468283,\n    0.1258374563468283,\n    0.12167047292780339,\n    0.12167047292780339,\n    0.1155056680537256,\n    0.1155056680537256,\n    0.10744427011596563,\n    0.10744427011596563,\n    0.09761865210411388,\n    0.09761865210411388,\n    0.08619016153195327,\n    0.08619016153195327,\n    0.0733464814110803,\n    0.0733464814110803,\n    0.05929858491543678,\n    0.05929858491543678,\n    0.04427743881741981,\n    0.04427743881741981,\n    0.028531388628933663,\n    0.028531388628933663,\n    0.0123412297999872,\n    0.0123412297999872\n  ]\n];\nvar binomialCoefficients = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]];\n\n// src/helpers/bezier-functions.ts\nvar cubicPoint = (xs, ys, t) => {\n  const x = (1 - t) * (1 - t) * (1 - t) * xs[0] + 3 * (1 - t) * (1 - t) * t * xs[1] + 3 * (1 - t) * t * t * xs[2] + t * t * t * xs[3];\n  const y = (1 - t) * (1 - t) * (1 - t) * ys[0] + 3 * (1 - t) * (1 - t) * t * ys[1] + 3 * (1 - t) * t * t * ys[2] + t * t * t * ys[3];\n  return { x, y };\n};\nvar getDerivative = (derivative, t, vs) => {\n  const n = vs.length - 1;\n  let value;\n  if (n === 0) {\n    return 0;\n  }\n  if (derivative === 0) {\n    value = 0;\n    for (let k = 0;k <= n; k++) {\n      value += binomialCoefficients[n][k] * (1 - t) ** (n - k) * t ** k * vs[k];\n    }\n    return value;\n  }\n  const _vs = new Array(n);\n  for (let k = 0;k < n; k++) {\n    _vs[k] = n * (vs[k + 1] - vs[k]);\n  }\n  return getDerivative(derivative - 1, t, _vs);\n};\nfunction bFunc(xs, ys, t) {\n  const xbase = getDerivative(1, t, xs);\n  const ybase = getDerivative(1, t, ys);\n  const combined = xbase * xbase + ybase * ybase;\n  return Math.sqrt(combined);\n}\nvar getCubicArcLength = ({\n  sx,\n  sy,\n  t\n}) => {\n  let correctedT;\n  const n = 20;\n  const z = t / 2;\n  let sum = 0;\n  for (let i = 0;i < n; i++) {\n    correctedT = z * tValues[n][i] + z;\n    sum += cValues[n][i] * bFunc(sx, sy, correctedT);\n  }\n  return z * sum;\n};\nvar quadraticPoint = (xs, ys, t) => {\n  const x = (1 - t) * (1 - t) * xs[0] + 2 * (1 - t) * t * xs[1] + t * t * xs[2];\n  const y = (1 - t) * (1 - t) * ys[0] + 2 * (1 - t) * t * ys[1] + t * t * ys[2];\n  return { x, y };\n};\nvar cubicDerivative = (xs, ys, t) => {\n  const derivative = quadraticPoint([3 * (xs[1] - xs[0]), 3 * (xs[2] - xs[1]), 3 * (xs[3] - xs[2])], [3 * (ys[1] - ys[0]), 3 * (ys[2] - ys[1]), 3 * (ys[3] - ys[2])], t);\n  return derivative;\n};\nvar getQuadraticArcLength = (xs, ys, t) => {\n  if (t === undefined) {\n    t = 1;\n  }\n  const ax = xs[0] - 2 * xs[1] + xs[2];\n  const ay = ys[0] - 2 * ys[1] + ys[2];\n  const bx = 2 * xs[1] - 2 * xs[0];\n  const by = 2 * ys[1] - 2 * ys[0];\n  const A = 4 * (ax * ax + ay * ay);\n  const B = 4 * (ax * bx + ay * by);\n  const C = bx * bx + by * by;\n  if (A === 0) {\n    return t * Math.sqrt((xs[2] - xs[0]) ** 2 + (ys[2] - ys[0]) ** 2);\n  }\n  const b = B / (2 * A);\n  const c = C / A;\n  const u = t + b;\n  const k = c - b * b;\n  const uuk = u * u + k > 0 ? Math.sqrt(u * u + k) : 0;\n  const bbk = b * b + k > 0 ? Math.sqrt(b * b + k) : 0;\n  const term = b + Math.sqrt(b * b + k) === 0 ? 0 : k * Math.log(Math.abs((u + uuk) / (b + bbk)));\n  return Math.sqrt(A) / 2 * (u * uuk - b * bbk + term);\n};\nvar quadraticDerivative = (xs, ys, t) => {\n  return {\n    x: (1 - t) * 2 * (xs[1] - xs[0]) + t * 2 * (xs[2] - xs[1]),\n    y: (1 - t) * 2 * (ys[1] - ys[0]) + t * 2 * (ys[2] - ys[1])\n  };\n};\nvar t2length = ({\n  length,\n  totalLength,\n  func\n}) => {\n  let error = 1;\n  let t = length / totalLength;\n  let step = (length - func(t)) / totalLength;\n  let numIterations = 0;\n  while (error > 0.001) {\n    const increasedTLength = func(t + step);\n    const increasedTError = Math.abs(length - increasedTLength) / totalLength;\n    if (increasedTError < error) {\n      error = increasedTError;\n      t += step;\n    } else {\n      const decreasedTLength = func(t - step);\n      const decreasedTError = Math.abs(length - decreasedTLength) / totalLength;\n      if (decreasedTError < error) {\n        error = decreasedTError;\n        t -= step;\n      } else {\n        step /= 2;\n      }\n    }\n    numIterations++;\n    if (numIterations > 500) {\n      break;\n    }\n  }\n  return t;\n};\n\n// src/helpers/bezier.ts\nvar makeQuadratic = ({\n  startX,\n  startY,\n  cpx,\n  cpy,\n  x,\n  y\n}) => {\n  const a = { x: startX, y: startY };\n  const b = { x: cpx, y: cpy };\n  const c = { x, y };\n  const length = getQuadraticArcLength([a.x, b.x, c.x, 0], [a.y, b.y, c.y, 0], 1);\n  const getTotalLength = () => {\n    return length;\n  };\n  const getPointAtLength = (len) => {\n    const xs = [a.x, b.x, c.x, 0];\n    const xy = [a.y, b.y, c.y, 0];\n    const t = t2length({\n      length: len,\n      totalLength: length,\n      func: (i) => getQuadraticArcLength(xs, xy, i)\n    });\n    return quadraticPoint(xs, xy, t);\n  };\n  const getTangentAtLength = (len) => {\n    const xs = [a.x, b.x, c.x, 0];\n    const xy = [a.y, b.y, c.y, 0];\n    const t = t2length({\n      length: len,\n      totalLength: length,\n      func: (i) => getQuadraticArcLength(xs, xy, i)\n    });\n    const derivative = quadraticDerivative(xs, xy, t);\n    const mdl = Math.sqrt(derivative.x * derivative.x + derivative.y * derivative.y);\n    let tangent;\n    if (mdl > 0) {\n      tangent = { x: derivative.x / mdl, y: derivative.y / mdl };\n    } else {\n      tangent = { x: 0, y: 0 };\n    }\n    return tangent;\n  };\n  const getC = () => {\n    return c;\n  };\n  return {\n    getPointAtLength,\n    getTangentAtLength,\n    getTotalLength,\n    getC,\n    type: \"quadratic-bezier\",\n    getD: () => ({ x: 0, y: 0 })\n  };\n};\nvar makeCubic = ({\n  startX,\n  startY,\n  cp1x,\n  cp1y,\n  cp2x,\n  cp2y,\n  x,\n  y\n}) => {\n  const a = { x: startX, y: startY };\n  const b = { x: cp1x, y: cp1y };\n  const c = { x: cp2x, y: cp2y };\n  const d = { x, y };\n  const length = getCubicArcLength({\n    sx: [a.x, b.x, c.x, d.x],\n    sy: [a.y, b.y, c.y, d.y],\n    t: 1\n  });\n  const getTotalLength = () => {\n    return length;\n  };\n  const getPointAtLength = (len) => {\n    const sx = [a.x, b.x, c.x, d.x];\n    const sy = [a.y, b.y, c.y, d.y];\n    const t = t2length({\n      length: len,\n      totalLength: length,\n      func: (i) => {\n        return getCubicArcLength({ sx, sy, t: i });\n      }\n    });\n    return cubicPoint(sx, sy, t);\n  };\n  const getTangentAtLength = (len) => {\n    const xs = [a.x, b.x, c.x, d.x];\n    const xy = [a.y, b.y, c.y, d.y];\n    const t = t2length({\n      length: len,\n      totalLength: length,\n      func: (i) => getCubicArcLength({ sx: xs, sy: xy, t: i })\n    });\n    const derivative = cubicDerivative(xs, xy, t);\n    const mdl = Math.sqrt(derivative.x * derivative.x + derivative.y * derivative.y);\n    let tangent;\n    if (mdl > 0) {\n      tangent = { x: derivative.x / mdl, y: derivative.y / mdl };\n    } else {\n      tangent = { x: 0, y: 0 };\n    }\n    return tangent;\n  };\n  const getC = () => {\n    return c;\n  };\n  const getD = () => {\n    return d;\n  };\n  return {\n    getPointAtLength,\n    getTangentAtLength,\n    getTotalLength,\n    getC,\n    getD,\n    type: \"cubic-bezier\"\n  };\n};\n\n// src/helpers/linear.ts\nvar makeLinearPosition = ({\n  x0,\n  x1,\n  y0,\n  y1\n}) => {\n  return {\n    getTotalLength: () => {\n      return Math.sqrt((x0 - x1) ** 2 + (y0 - y1) ** 2);\n    },\n    getPointAtLength: (pos) => {\n      let fraction = pos / Math.sqrt((x0 - x1) ** 2 + (y0 - y1) ** 2);\n      fraction = Number.isNaN(fraction) ? 1 : fraction;\n      const newDeltaX = (x1 - x0) * fraction;\n      const newDeltaY = (y1 - y0) * fraction;\n      return { x: x0 + newDeltaX, y: y0 + newDeltaY };\n    },\n    getTangentAtLength: () => {\n      const module = Math.sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));\n      return { x: (x1 - x0) / module, y: (y1 - y0) / module };\n    },\n    type: \"linear\"\n  };\n};\n\n// src/helpers/reduced-analysis.ts\nvar conductAnalysis = (instructions) => {\n  let currentPoint = { x: 0, y: 0 };\n  let moveStart = { x: 0, y: 0 };\n  const segments = [];\n  for (let i = 0;i < instructions.length; i++) {\n    const instruction = instructions[i];\n    if (instruction.type === \"M\") {\n      currentPoint = { x: instruction.x, y: instruction.y };\n      moveStart = { x: currentPoint.x, y: currentPoint.y };\n      segments.push({\n        startPoint: { x: instruction.x, y: instruction.y },\n        instructionsAndInfo: [\n          {\n            instruction,\n            function: null,\n            length: 0,\n            startPoint: currentPoint\n          }\n        ]\n      });\n    }\n    if (instruction.type === \"L\") {\n      if (segments.length > 0) {\n        const length = Math.sqrt((currentPoint.x - instruction.x) ** 2 + (currentPoint.y - instruction.y) ** 2);\n        segments[segments.length - 1].instructionsAndInfo.push({\n          instruction,\n          length,\n          function: makeLinearPosition({\n            x0: currentPoint.x,\n            x1: instruction.x,\n            y0: currentPoint.y,\n            y1: instruction.y\n          }),\n          startPoint: currentPoint\n        });\n      }\n      currentPoint = { x: instruction.x, y: instruction.y };\n    }\n    if (instruction.type === \"Z\") {\n      if (segments.length > 0) {\n        const length = Math.sqrt((segments[segments.length - 1].startPoint.x - currentPoint.x) ** 2 + (segments[segments.length - 1].startPoint.y - currentPoint.y) ** 2);\n        segments[segments.length - 1].instructionsAndInfo.push({\n          instruction,\n          function: makeLinearPosition({\n            x0: currentPoint.x,\n            x1: moveStart.x,\n            y0: currentPoint.y,\n            y1: moveStart.y\n          }),\n          length,\n          startPoint: { ...currentPoint }\n        });\n      }\n      currentPoint = { x: moveStart.x, y: moveStart.y };\n    }\n    if (instruction.type === \"C\") {\n      const curve = makeCubic({\n        startX: currentPoint.x,\n        startY: currentPoint.y,\n        cp1x: instruction.cp1x,\n        cp1y: instruction.cp1y,\n        cp2x: instruction.cp2x,\n        cp2y: instruction.cp2y,\n        x: instruction.x,\n        y: instruction.y\n      });\n      const length = curve.getTotalLength();\n      if (segments.length > 0) {\n        segments[segments.length - 1].instructionsAndInfo.push({\n          instruction,\n          length,\n          function: curve,\n          startPoint: { ...currentPoint }\n        });\n      }\n      currentPoint = { x: instruction.x, y: instruction.y };\n    }\n  }\n  return segments;\n};\n\n// src/parse-path.ts\nvar length = {\n  a: 7,\n  A: 7,\n  C: 6,\n  c: 6,\n  H: 1,\n  h: 1,\n  L: 2,\n  l: 2,\n  M: 2,\n  m: 2,\n  Q: 4,\n  q: 4,\n  S: 4,\n  s: 4,\n  T: 2,\n  t: 2,\n  V: 1,\n  v: 1,\n  Z: 0,\n  z: 0\n};\nvar chunkExact = (array, instruction) => {\n  const chunks = [];\n  const expectedSize = length[instruction];\n  if (array.length % expectedSize !== 0) {\n    throw new Error(`Expected number of arguments of SVG instruction \"${instruction} ${array.join(\" \")}\" to be a multiple of ${expectedSize}`);\n  }\n  for (let i = 0;i < array.length; i += expectedSize) {\n    chunks.push(array.slice(i, i + expectedSize));\n  }\n  return chunks;\n};\nvar makeInstructions = (arr, instruction, cb) => {\n  return chunkExact(arr, instruction).map((args) => {\n    return cb(args);\n  });\n};\nvar segmentRegExp = /([astvzqmhlc])([^astvzqmhlc]*)/gi;\nvar numberRegExp = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/gi;\nvar parseValues = (args, instructionType) => {\n  const numbers = args.match(numberRegExp);\n  if (!numbers) {\n    if (instructionType === \"Z\" || instructionType === \"z\") {\n      return [];\n    }\n    throw new Error(`Malformed path data: ${instructionType} was expected to have numbers afterwards`);\n  }\n  const expectedArguments = length[instructionType];\n  if (numbers.length % expectedArguments !== 0) {\n    throw new Error(`Malformed path data: ${instructionType} was expected to have a multiple of ${expectedArguments} numbers, but got \"${instructionType} ${numbers.join(\" \")} instead\"`);\n  }\n  return numbers.map(Number);\n};\nvar parsePath = (path) => {\n  if (!path) {\n    throw new Error(\"No path provided\");\n  }\n  const segments = path.match(segmentRegExp);\n  if (!segments) {\n    throw new Error(`No path elements found in string ${path}`);\n  }\n  return segments.map((segmentString) => {\n    const command = segmentString.charAt(0);\n    const args = parseValues(segmentString.substring(1), command);\n    if (command === \"M\" && args.length > 2) {\n      const segmentsArray = [];\n      segmentsArray.push({\n        type: command,\n        x: args[0],\n        y: args[1]\n      });\n      segmentsArray.push(...makeInstructions(args.slice(2), \"L\", (numbers) => ({\n        type: \"L\",\n        x: numbers[0],\n        y: numbers[1]\n      })));\n      return segmentsArray;\n    }\n    if (command === \"m\" && args.length > 2) {\n      const segmentsArray = [];\n      segmentsArray.push({\n        type: command,\n        dx: args[0],\n        dy: args[1]\n      });\n      segmentsArray.push(...makeInstructions(args.slice(2), \"l\", (numbers) => ({\n        type: \"l\",\n        dx: numbers[0],\n        dy: numbers[1]\n      })));\n      return segmentsArray;\n    }\n    if (command === \"Z\" || command === \"z\") {\n      return [\n        {\n          type: \"Z\"\n        }\n      ];\n    }\n    if (command === \"A\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        rx: numbers[0],\n        ry: numbers[1],\n        xAxisRotation: numbers[2],\n        largeArcFlag: numbers[3] === 1,\n        sweepFlag: numbers[4] === 1,\n        x: numbers[5],\n        y: numbers[6]\n      }));\n    }\n    if (command === \"a\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        rx: numbers[0],\n        ry: numbers[1],\n        xAxisRotation: numbers[2],\n        largeArcFlag: numbers[3] === 1,\n        sweepFlag: numbers[4] === 1,\n        dx: numbers[5],\n        dy: numbers[6]\n      }));\n    }\n    if (command === \"C\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        cp1x: numbers[0],\n        cp1y: numbers[1],\n        cp2x: numbers[2],\n        cp2y: numbers[3],\n        x: numbers[4],\n        y: numbers[5]\n      }));\n    }\n    if (command === \"c\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        cp1dx: numbers[0],\n        cp1dy: numbers[1],\n        cp2dx: numbers[2],\n        cp2dy: numbers[3],\n        dx: numbers[4],\n        dy: numbers[5]\n      }));\n    }\n    if (command === \"S\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        cpx: numbers[0],\n        cpy: numbers[1],\n        x: numbers[2],\n        y: numbers[3]\n      }));\n    }\n    if (command === \"s\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        cpdx: numbers[0],\n        cpdy: numbers[1],\n        dx: numbers[2],\n        dy: numbers[3]\n      }));\n    }\n    if (command === \"H\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        x: numbers[0]\n      }));\n    }\n    if (command === \"h\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        dx: numbers[0]\n      }));\n    }\n    if (command === \"V\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        y: numbers[0]\n      }));\n    }\n    if (command === \"v\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        dy: numbers[0]\n      }));\n    }\n    if (command === \"L\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        x: numbers[0],\n        y: numbers[1]\n      }));\n    }\n    if (command === \"M\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        x: numbers[0],\n        y: numbers[1]\n      }));\n    }\n    if (command === \"m\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        dx: numbers[0],\n        dy: numbers[1]\n      }));\n    }\n    if (command === \"l\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        dx: numbers[0],\n        dy: numbers[1]\n      }));\n    }\n    if (command === \"Q\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        cpx: numbers[0],\n        cpy: numbers[1],\n        x: numbers[2],\n        y: numbers[3]\n      }));\n    }\n    if (command === \"q\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        cpdx: numbers[0],\n        cpdy: numbers[1],\n        dx: numbers[2],\n        dy: numbers[3]\n      }));\n    }\n    if (command === \"T\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        x: numbers[0],\n        y: numbers[1]\n      }));\n    }\n    if (command === \"t\") {\n      return makeInstructions(args, command, (numbers) => ({\n        type: command,\n        dx: numbers[0],\n        dy: numbers[1]\n      }));\n    }\n    throw new Error(`Invalid path element ${segmentString}`);\n  }, []).flat(1);\n};\n\n// src/helpers/convert-q-to-c-instruction.ts\nvar convertQToCInstruction = (instruction, startPoint) => {\n  const cp1x = startPoint.x + 2 / 3 * (instruction.cpx - startPoint.x);\n  const cp1y = startPoint.y + 2 / 3 * (instruction.cpy - startPoint.y);\n  const cp2x = instruction.x + 2 / 3 * (instruction.cpx - instruction.x);\n  const cp2y = instruction.y + 2 / 3 * (instruction.cpy - instruction.y);\n  return {\n    type: \"C\",\n    cp1x,\n    cp1y,\n    cp2x,\n    cp2y,\n    x: instruction.x,\n    y: instruction.y\n  };\n};\n\n// src/helpers/iterate.ts\nvar iterateOverSegments = ({\n  segments,\n  iterate\n}) => {\n  let x = 0;\n  let y = 0;\n  let initialX = 0;\n  let initialY = 0;\n  let cpX = null;\n  let cpY = null;\n  const newSegments = segments.map((s, i) => {\n    const newSeg = iterate({\n      segment: s,\n      x,\n      y,\n      prevSegment: segments[i - 1] ?? null,\n      initialX,\n      initialY,\n      cpX,\n      cpY\n    });\n    switch (s.type) {\n      case \"M\":\n        initialX = s.x;\n        initialY = s.y;\n        x = s.x;\n        y = s.y;\n        cpX = null;\n        cpY = null;\n        break;\n      case \"Q\":\n        x = s.x;\n        y = s.y;\n        cpX = s.cpx;\n        cpY = s.cpy;\n        break;\n      case \"A\":\n        x = s.x;\n        y = s.y;\n        cpX = null;\n        cpY = null;\n        break;\n      case \"C\":\n        x = s.x;\n        y = s.y;\n        cpX = s.cp2x;\n        cpY = s.cp2y;\n        break;\n      case \"S\":\n        x = s.x;\n        y = s.y;\n        cpX = s.cpx;\n        cpY = s.cpy;\n        break;\n      case \"T\":\n        if (cpX !== null && cpY !== null) {\n          cpX = x - (cpX - x);\n          cpY = y - (cpY - y);\n        }\n        x = s.x;\n        y = s.y;\n        break;\n      case \"L\":\n        x = s.x;\n        y = s.y;\n        cpX = null;\n        cpY = null;\n        break;\n      case \"V\":\n        y = s.y;\n        cpX = null;\n        cpY = null;\n        break;\n      case \"H\":\n        x = s.x;\n        cpX = null;\n        cpY = null;\n        break;\n      case \"Z\":\n        x = initialX;\n        y = initialY;\n        cpX = null;\n        cpY = null;\n        break;\n      default:\n        throw new Error(`Unexpected instruction ${s.type}`);\n    }\n    return newSeg;\n  });\n  return newSegments.flat(1);\n};\n\n// src/helpers/remove-a-s-t-curves.ts\nvar TAU = Math.PI * 2;\nfunction approximate_unit_arc(theta1, delta_theta) {\n  const alpha = 4 / 3 * Math.tan(delta_theta / 4);\n  const x1 = Math.cos(theta1);\n  const y1 = Math.sin(theta1);\n  const x2 = Math.cos(theta1 + delta_theta);\n  const y2 = Math.sin(theta1 + delta_theta);\n  return [\n    x1,\n    y1,\n    x1 - y1 * alpha,\n    y1 + x1 * alpha,\n    x2 + y2 * alpha,\n    y2 - x2 * alpha,\n    x2,\n    y2\n  ];\n}\nfunction unit_vector_angle(ux, uy, vx, vy) {\n  const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  let dot = ux * vx + uy * vy;\n  if (dot > 1) {\n    dot = 1;\n  }\n  if (dot < -1) {\n    dot = -1;\n  }\n  return sign * Math.acos(dot);\n}\nfunction get_arc_center({\n  x1,\n  y1,\n  x2,\n  y2,\n  largeArcFlag,\n  sweepFlag,\n  rx,\n  ry,\n  sin_phi,\n  cos_phi\n}) {\n  const x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;\n  const y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;\n  const rx_sq = rx * rx;\n  const ry_sq = ry * ry;\n  const x1p_sq = x1p * x1p;\n  const y1p_sq = y1p * y1p;\n  let radicant = rx_sq * ry_sq - rx_sq * y1p_sq - ry_sq * x1p_sq;\n  if (radicant < 0) {\n    radicant = 0;\n  }\n  radicant /= rx_sq * y1p_sq + ry_sq * x1p_sq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  const cxp = radicant * rx / ry * y1p;\n  const cyp = radicant * -ry / rx * x1p;\n  const cx = cos_phi * cxp - sin_phi * cyp + (x1 + x2) / 2;\n  const cy = sin_phi * cxp + cos_phi * cyp + (y1 + y2) / 2;\n  const v1x = (x1p - cxp) / rx;\n  const v1y = (y1p - cyp) / ry;\n  const v2x = (-x1p - cxp) / rx;\n  const v2y = (-y1p - cyp) / ry;\n  const theta1 = unit_vector_angle(1, 0, v1x, v1y);\n  let delta_theta = unit_vector_angle(v1x, v1y, v2x, v2y);\n  if (sweepFlag === false && delta_theta > 0) {\n    delta_theta -= TAU;\n  }\n  if (sweepFlag === true && delta_theta < 0) {\n    delta_theta += TAU;\n  }\n  return [cx, cy, theta1, delta_theta];\n}\nfunction arcToCircle({\n  x1,\n  y1,\n  x2,\n  y2,\n  largeArcFlag,\n  sweepFlag,\n  rx,\n  ry,\n  phi\n}) {\n  const sin_phi = Math.sin(phi * TAU / 360);\n  const cos_phi = Math.cos(phi * TAU / 360);\n  const x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;\n  const y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;\n  if (x1p === 0 && y1p === 0) {\n    return [];\n  }\n  if (rx === 0 || ry === 0) {\n    return [];\n  }\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const lambda = x1p * x1p / (rx * rx) + y1p * y1p / (ry * ry);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  const cc = get_arc_center({\n    x1,\n    y1,\n    x2,\n    y2,\n    largeArcFlag,\n    sweepFlag,\n    rx,\n    ry,\n    sin_phi,\n    cos_phi\n  });\n  const result = [];\n  let theta1 = cc[2];\n  let delta_theta = cc[3];\n  const segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);\n  delta_theta /= segments;\n  for (let i = 0;i < segments; i++) {\n    result.push(approximate_unit_arc(theta1, delta_theta));\n    theta1 += delta_theta;\n  }\n  return result.map((curve) => {\n    for (let i = 0;i < curve.length; i += 2) {\n      let x = curve[i + 0];\n      let y = curve[i + 1];\n      x *= rx;\n      y *= ry;\n      const xp = cos_phi * x - sin_phi * y;\n      const yp = sin_phi * x + cos_phi * y;\n      curve[i + 0] = xp + cc[0];\n      curve[i + 1] = yp + cc[1];\n    }\n    return curve;\n  });\n}\nvar removeATSHVQInstructions = (segments) => {\n  return iterateOverSegments({\n    segments,\n    iterate: ({ segment, prevSegment, x, y, cpX, cpY }) => {\n      if (segment.type === \"H\") {\n        return [{ type: \"L\", x: segment.x, y }];\n      }\n      if (segment.type === \"V\") {\n        return [{ type: \"L\", x, y: segment.y }];\n      }\n      if (segment.type === \"A\") {\n        const nextX = segment.x;\n        const nextY = segment.y;\n        const new_segments = arcToCircle({\n          x1: x,\n          y1: y,\n          x2: nextX,\n          y2: nextY,\n          largeArcFlag: segment.largeArcFlag,\n          sweepFlag: segment.sweepFlag,\n          rx: segment.rx,\n          ry: segment.ry,\n          phi: segment.xAxisRotation\n        });\n        if (new_segments.length === 0) {\n          return [\n            {\n              type: \"L\",\n              x: segment.x,\n              y: segment.y\n            }\n          ];\n        }\n        const result = new_segments.map((_s) => {\n          return {\n            type: \"C\",\n            cp1x: _s[2],\n            cp1y: _s[3],\n            cp2x: _s[4],\n            cp2y: _s[5],\n            x: _s[6],\n            y: _s[7]\n          };\n        });\n        return result;\n      }\n      if (segment.type === \"T\") {\n        let prevControlX = 0;\n        let prevControlY = 0;\n        if (prevSegment && (prevSegment.type === \"Q\" || prevSegment.type === \"T\")) {\n          prevControlX = cpX;\n          prevControlY = cpY;\n        } else {\n          prevControlX = x;\n          prevControlY = y;\n        }\n        const vectorX = prevControlX - x;\n        const vectorY = prevControlY - y;\n        const newControlX = x - vectorX;\n        const newControlY = y - vectorY;\n        return [\n          convertQToCInstruction({\n            type: \"Q\",\n            cpx: newControlX,\n            cpy: newControlY,\n            x: segment.x,\n            y: segment.y\n          }, { x, y })\n        ];\n      }\n      if (segment.type === \"S\") {\n        let prevControlX = 0;\n        let prevControlY = 0;\n        if (prevSegment && prevSegment.type === \"C\") {\n          prevControlX = prevSegment.cp2x;\n          prevControlY = prevSegment.cp2y;\n        } else if (prevSegment && prevSegment.type === \"S\") {\n          prevControlX = prevSegment.cpx;\n          prevControlY = prevSegment.cpy;\n        } else {\n          prevControlX = x;\n          prevControlY = y;\n        }\n        const vectorX = prevControlX - x;\n        const vectorY = prevControlY - y;\n        const newControlX = x - vectorX;\n        const newControlY = y - vectorY;\n        return [\n          {\n            type: \"C\",\n            cp1x: newControlX,\n            cp1y: newControlY,\n            cp2x: segment.cpx,\n            cp2y: segment.cpy,\n            x: segment.x,\n            y: segment.y\n          }\n        ];\n      }\n      if (segment.type === \"Q\") {\n        return [convertQToCInstruction(segment, { x, y })];\n      }\n      return [segment];\n    }\n  });\n};\n\n// src/serialize-instructions.ts\nvar serializeInstruction = (instruction) => {\n  if (instruction.type === \"A\") {\n    return `A ${instruction.rx} ${instruction.ry} ${instruction.xAxisRotation} ${Number(instruction.largeArcFlag)} ${Number(instruction.sweepFlag)} ${instruction.x} ${instruction.y}`;\n  }\n  if (instruction.type === \"a\") {\n    return `a ${instruction.rx} ${instruction.ry} ${instruction.xAxisRotation} ${Number(instruction.largeArcFlag)} ${Number(instruction.sweepFlag)} ${instruction.dx} ${instruction.dy}`;\n  }\n  if (instruction.type === \"C\") {\n    return `C ${instruction.cp1x} ${instruction.cp1y} ${instruction.cp2x} ${instruction.cp2y} ${instruction.x} ${instruction.y}`;\n  }\n  if (instruction.type === \"c\") {\n    return `c ${instruction.cp1dx} ${instruction.cp1dy} ${instruction.cp2dx} ${instruction.cp2dy} ${instruction.dx} ${instruction.dy}`;\n  }\n  if (instruction.type === \"S\") {\n    return `S ${instruction.cpx} ${instruction.cpy} ${instruction.x} ${instruction.y}`;\n  }\n  if (instruction.type === \"s\") {\n    return `s ${instruction.cpdx} ${instruction.cpdy} ${instruction.dx} ${instruction.dy}`;\n  }\n  if (instruction.type === \"Q\") {\n    return `Q ${instruction.cpx} ${instruction.cpy} ${instruction.x} ${instruction.y}`;\n  }\n  if (instruction.type === \"q\") {\n    return `q ${instruction.cpdx} ${instruction.cpdy} ${instruction.dx} ${instruction.dy}`;\n  }\n  if (instruction.type === \"Z\") {\n    return \"Z\";\n  }\n  if (instruction.type === \"H\") {\n    return `H ${instruction.x}`;\n  }\n  if (instruction.type === \"h\") {\n    return `h ${instruction.dx}`;\n  }\n  if (instruction.type === \"V\") {\n    return `V ${instruction.y}`;\n  }\n  if (instruction.type === \"v\") {\n    return `v ${instruction.dy}`;\n  }\n  if (instruction.type === \"L\") {\n    return `L ${instruction.x} ${instruction.y}`;\n  }\n  if (instruction.type === \"l\") {\n    return `l ${instruction.dx} ${instruction.dy}`;\n  }\n  if (instruction.type === \"M\") {\n    return `M ${instruction.x} ${instruction.y}`;\n  }\n  if (instruction.type === \"m\") {\n    return `m ${instruction.dx} ${instruction.dy}`;\n  }\n  if (instruction.type === \"T\") {\n    return `T ${instruction.x} ${instruction.y}`;\n  }\n  if (instruction.type === \"t\") {\n    return `t ${instruction.dx} ${instruction.dy}`;\n  }\n  throw new Error(`Unknown instruction type: ${instruction.type}`);\n};\nvar serializeInstructions = (path) => {\n  return path.map((p) => {\n    return serializeInstruction(p);\n  }).join(\" \");\n};\n\n// src/normalize-path.ts\nvar normalizeInstructions = (instructions) => {\n  const normalized = [];\n  let x = 0;\n  let y = 0;\n  let moveX = 0;\n  let moveY = 0;\n  for (let i = 0;i < instructions.length; i++) {\n    const instruction = instructions[i];\n    if (instruction.type === \"M\") {\n      moveX = instruction.x;\n      moveY = instruction.y;\n    } else if (instruction.type === \"m\") {\n      moveX += instruction.dx;\n      moveY += instruction.dy;\n    }\n    if (instruction.type === \"A\" || instruction.type === \"C\" || instruction.type === \"L\" || instruction.type === \"M\" || instruction.type === \"Q\" || instruction.type === \"S\" || instruction.type === \"T\") {\n      normalized.push(instruction);\n      x = instruction.x;\n      y = instruction.y;\n      continue;\n    }\n    if (instruction.type === \"a\" || instruction.type === \"c\" || instruction.type === \"l\" || instruction.type === \"m\" || instruction.type === \"q\" || instruction.type === \"s\" || instruction.type === \"t\") {\n      const currentX = x;\n      const currentY = y;\n      x += instruction.dx;\n      y += instruction.dy;\n      if (instruction.type === \"a\") {\n        normalized.push({\n          type: \"A\",\n          largeArcFlag: instruction.largeArcFlag,\n          rx: instruction.rx,\n          ry: instruction.ry,\n          sweepFlag: instruction.sweepFlag,\n          xAxisRotation: instruction.xAxisRotation,\n          x,\n          y\n        });\n        continue;\n      }\n      if (instruction.type === \"c\") {\n        normalized.push({\n          type: \"C\",\n          cp1x: instruction.cp1dx + currentX,\n          cp1y: instruction.cp1dy + currentY,\n          cp2x: instruction.cp2dx + currentX,\n          cp2y: instruction.cp2dy + currentY,\n          x,\n          y\n        });\n        continue;\n      }\n      if (instruction.type === \"l\") {\n        normalized.push({\n          type: \"L\",\n          x,\n          y\n        });\n        continue;\n      }\n      if (instruction.type === \"m\") {\n        normalized.push({\n          type: \"M\",\n          x,\n          y\n        });\n        continue;\n      }\n      if (instruction.type === \"q\") {\n        normalized.push({\n          type: \"Q\",\n          cpx: instruction.cpdx + currentX,\n          cpy: instruction.cpdy + currentY,\n          x,\n          y\n        });\n        continue;\n      }\n      if (instruction.type === \"s\") {\n        normalized.push({\n          type: \"S\",\n          cpx: instruction.cpdx + currentX,\n          cpy: instruction.cpdy + currentY,\n          x,\n          y\n        });\n        continue;\n      }\n      if (instruction.type === \"t\") {\n        normalized.push({\n          type: \"T\",\n          x,\n          y\n        });\n        continue;\n      }\n    }\n    if (instruction.type === \"H\") {\n      normalized.push(instruction);\n      x = instruction.x;\n      continue;\n    }\n    if (instruction.type === \"V\") {\n      normalized.push(instruction);\n      y = instruction.y;\n      continue;\n    }\n    if (instruction.type === \"Z\") {\n      normalized.push(instruction);\n      x = moveX;\n      y = moveY;\n      continue;\n    }\n    if (instruction.type === \"h\") {\n      x += instruction.dx;\n      normalized.push({\n        type: \"H\",\n        x\n      });\n      continue;\n    }\n    if (instruction.type === \"v\") {\n      y += instruction.dy;\n      normalized.push({\n        type: \"V\",\n        y\n      });\n      continue;\n    }\n    throw new Error(\"Unknown instruction type: \" + instruction.type);\n  }\n  return normalized;\n};\nvar normalizePath = (path) => {\n  const instructions = parsePath(path);\n  const normalized = normalizeInstructions(instructions);\n  return serializeInstructions(normalized);\n};\n\n// src/reduce-instructions.ts\nvar reduceInstructions = (instruction) => {\n  const simplified = normalizeInstructions(instruction);\n  return removeATSHVQInstructions(simplified);\n};\n\n// src/cut-path.ts\nvar cutPath = (d, length2) => {\n  const parsed = parsePath(d);\n  const reduced = reduceInstructions(parsed);\n  const constructed = conductAnalysis(reduced);\n  const newInstructions = [];\n  let summedUpLength = 0;\n  for (const segment of constructed) {\n    for (const instructionAndInfo of segment.instructionsAndInfo) {\n      if (summedUpLength + instructionAndInfo.length > length2) {\n        const remainingLength = length2 - summedUpLength;\n        const progress = remainingLength / instructionAndInfo.length;\n        const cut = cutInstruction({\n          instruction: instructionAndInfo.instruction,\n          lastPoint: instructionAndInfo.startPoint,\n          progress\n        });\n        newInstructions.push(cut);\n        return serializeInstructions(newInstructions);\n      }\n      summedUpLength += instructionAndInfo.length;\n      newInstructions.push(instructionAndInfo.instruction);\n      if (summedUpLength === length2) {\n        return serializeInstructions(newInstructions);\n      }\n    }\n  }\n  return serializeInstructions(newInstructions);\n};\n\n// src/debug-path.ts\nvar debugPath = (d) => {\n  const instructions = normalizeInstructions(parsePath(d));\n  return instructions.map((inst, i) => {\n    if (inst.type === \"Z\") {\n      return null;\n    }\n    if (inst.type === \"H\" || inst.type === \"V\") {\n      return null;\n    }\n    const topLeft = [inst.x - 5, inst.y - 5];\n    const topRight = [inst.x + 5, inst.y - 5];\n    const bottomLeft = [inst.x - 5, inst.y + 5];\n    const bottomRight = [inst.x + 5, inst.y + 5];\n    const triangle = [\n      {\n        type: \"M\",\n        x: topLeft[0],\n        y: topLeft[1]\n      },\n      {\n        type: \"L\",\n        x: topRight[0],\n        y: topRight[1]\n      },\n      {\n        type: \"L\",\n        x: bottomRight[0],\n        y: bottomRight[1]\n      },\n      {\n        type: \"L\",\n        x: bottomLeft[0],\n        y: bottomLeft[1]\n      },\n      {\n        type: \"Z\"\n      }\n    ];\n    return {\n      d: serializeInstructions(triangle),\n      color: i === instructions.length - 1 ? \"red\" : inst.type === \"M\" ? \"blue\" : \"green\"\n    };\n  }).filter(Boolean);\n};\n\n// src/get-bounding-box.ts\nvar CBEZIER_MINMAX_EPSILON = 0.00000001;\nfunction minmaxQ(A) {\n  const min = Math.min(A[0], A[2]);\n  const max = Math.max(A[0], A[2]);\n  if (A[1] > A[0] ? A[2] >= A[1] : A[2] <= A[1]) {\n    return [min, max];\n  }\n  const E = (A[0] * A[2] - A[1] * A[1]) / (A[0] - 2 * A[1] + A[2]);\n  return E < min ? [E, max] : [min, E];\n}\nfunction minmaxC(A) {\n  const K = A[0] - 3 * A[1] + 3 * A[2] - A[3];\n  if (Math.abs(K) < CBEZIER_MINMAX_EPSILON) {\n    if (A[0] === A[3] && A[0] === A[1]) {\n      return [A[0], A[3]];\n    }\n    return minmaxQ([\n      A[0],\n      -0.5 * A[0] + 1.5 * A[1],\n      A[0] - 3 * A[1] + 3 * A[2]\n    ]);\n  }\n  const T = -A[0] * A[2] + A[0] * A[3] - A[1] * A[2] - A[1] * A[3] + A[1] * A[1] + A[2] * A[2];\n  if (T <= 0) {\n    return [Math.min(A[0], A[3]), Math.max(A[0], A[3])];\n  }\n  const S = Math.sqrt(T);\n  let min = Math.min(A[0], A[3]);\n  let max = Math.max(A[0], A[3]);\n  const L = A[0] - 2 * A[1] + A[2];\n  for (let R = (L + S) / K, i = 1;i <= 2; R = (L - S) / K, i++) {\n    if (R > 0 && R < 1) {\n      const Q = A[0] * (1 - R) * (1 - R) * (1 - R) + A[1] * 3 * (1 - R) * (1 - R) * R + A[2] * 3 * (1 - R) * R * R + A[3] * R * R * R;\n      if (Q < min) {\n        min = Q;\n      }\n      if (Q > max) {\n        max = Q;\n      }\n    }\n  }\n  return [min, max];\n}\nvar getBoundingBoxFromInstructions = (instructions) => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let x = 0;\n  let y = 0;\n  let lastMoveX = 0;\n  let lastMoveY = 0;\n  for (const seg of instructions) {\n    switch (seg.type) {\n      case \"M\": {\n        lastMoveX = seg.x;\n        lastMoveY = seg.y;\n        if (minX > seg.x) {\n          minX = seg.x;\n        }\n        if (minY > seg.y) {\n          minY = seg.y;\n        }\n        if (maxX < seg.x) {\n          maxX = seg.x;\n        }\n        if (maxY < seg.y) {\n          maxY = seg.y;\n        }\n        x = seg.x;\n        y = seg.y;\n        break;\n      }\n      case \"L\": {\n        if (minX > seg.x) {\n          minX = seg.x;\n        }\n        if (minY > seg.y) {\n          minY = seg.y;\n        }\n        if (maxX < seg.x) {\n          maxX = seg.x;\n        }\n        if (maxY < seg.y) {\n          maxY = seg.y;\n        }\n        x = seg.x;\n        y = seg.y;\n        break;\n      }\n      case \"C\": {\n        const cxMinMax = minmaxC([x, seg.cp1x, seg.cp2x, seg.x]);\n        if (minX > cxMinMax[0]) {\n          minX = cxMinMax[0];\n        }\n        if (maxX < cxMinMax[1]) {\n          maxX = cxMinMax[1];\n        }\n        const cyMinMax = minmaxC([y, seg.cp1y, seg.cp2y, seg.y]);\n        if (minY > cyMinMax[0]) {\n          minY = cyMinMax[0];\n        }\n        if (maxY < cyMinMax[1]) {\n          maxY = cyMinMax[1];\n        }\n        x = seg.x;\n        y = seg.y;\n        break;\n      }\n      case \"Z\":\n        x = lastMoveX;\n        y = lastMoveY;\n        break;\n      default:\n        throw new Error(`Unknown instruction ${seg.type}`);\n    }\n  }\n  return {\n    x1: minX,\n    y1: minY,\n    x2: maxX,\n    y2: maxY,\n    viewBox: `${minX} ${minY} ${maxX - minX} ${maxY - minY}`,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n};\nvar getBoundingBox = (d) => {\n  const parsed = parsePath(d);\n  const unarced = removeATSHVQInstructions(normalizeInstructions(parsed));\n  return getBoundingBoxFromInstructions(unarced);\n};\n// src/helpers/arc.ts\nvar mod = (x, m) => {\n  return (x % m + m) % m;\n};\nvar toRadians = (angle) => {\n  return angle * (Math.PI / 180);\n};\nvar distance = (p0, p1) => {\n  return Math.sqrt((p1.x - p0.x) ** 2 + (p1.y - p0.y) ** 2);\n};\nvar clamp = (val, min, max) => {\n  return Math.min(Math.max(val, min), max);\n};\nvar angleBetween = (v0, v1) => {\n  const p = v0.x * v1.x + v0.y * v1.y;\n  const n = Math.sqrt((v0.x ** 2 + v0.y ** 2) * (v1.x ** 2 + v1.y ** 2));\n  const sign = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;\n  const angle = sign * Math.acos(p / n);\n  return angle;\n};\nvar pointOnEllipticalArc = ({\n  p0,\n  rx,\n  ry,\n  xAxisRotation,\n  largeArcFlag,\n  sweepFlag,\n  p1,\n  t\n}) => {\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  xAxisRotation = mod(xAxisRotation, 360);\n  const xAxisRotationRadians = toRadians(xAxisRotation);\n  if (p0.x === p1.x && p0.y === p1.y) {\n    return { x: p0.x, y: p0.y, ellipticalArcAngle: 0 };\n  }\n  if (rx === 0 || ry === 0) {\n    return { x: 0, y: 0, ellipticalArcAngle: 0 };\n  }\n  const dx = (p0.x - p1.x) / 2;\n  const dy = (p0.y - p1.y) / 2;\n  const transformedPoint = {\n    x: Math.cos(xAxisRotationRadians) * dx + Math.sin(xAxisRotationRadians) * dy,\n    y: -Math.sin(xAxisRotationRadians) * dx + Math.cos(xAxisRotationRadians) * dy\n  };\n  const radiiCheck = transformedPoint.x ** 2 / rx ** 2 + transformedPoint.y ** 2 / ry ** 2;\n  if (radiiCheck > 1) {\n    rx *= Math.sqrt(radiiCheck);\n    ry *= Math.sqrt(radiiCheck);\n  }\n  const cSquareNumerator = rx ** 2 * ry ** 2 - rx ** 2 * transformedPoint.y ** 2 - ry ** 2 * transformedPoint.x ** 2;\n  const cSquareRootDenom = rx ** 2 * transformedPoint.y ** 2 + ry ** 2 * transformedPoint.x ** 2;\n  let cRadicand = cSquareNumerator / cSquareRootDenom;\n  cRadicand = cRadicand < 0 ? 0 : cRadicand;\n  const cCoef = (largeArcFlag === sweepFlag ? -1 : 1) * Math.sqrt(cRadicand);\n  const transformedCenter = {\n    x: cCoef * (rx * transformedPoint.y / ry),\n    y: cCoef * (-(ry * transformedPoint.x) / rx)\n  };\n  const center = {\n    x: Math.cos(xAxisRotationRadians) * transformedCenter.x - Math.sin(xAxisRotationRadians) * transformedCenter.y + (p0.x + p1.x) / 2,\n    y: Math.sin(xAxisRotationRadians) * transformedCenter.x + Math.cos(xAxisRotationRadians) * transformedCenter.y + (p0.y + p1.y) / 2\n  };\n  const startVector = {\n    x: (transformedPoint.x - transformedCenter.x) / rx,\n    y: (transformedPoint.y - transformedCenter.y) / ry\n  };\n  const startAngle = angleBetween({\n    x: 1,\n    y: 0\n  }, startVector);\n  const endVector = {\n    x: (-transformedPoint.x - transformedCenter.x) / rx,\n    y: (-transformedPoint.y - transformedCenter.y) / ry\n  };\n  let sweepAngle = angleBetween(startVector, endVector);\n  if (!sweepFlag && sweepAngle > 0) {\n    sweepAngle -= 2 * Math.PI;\n  } else if (sweepFlag && sweepAngle < 0) {\n    sweepAngle += 2 * Math.PI;\n  }\n  sweepAngle %= 2 * Math.PI;\n  const angle = startAngle + sweepAngle * t;\n  const ellipseComponentX = rx * Math.cos(angle);\n  const ellipseComponentY = ry * Math.sin(angle);\n  const point = {\n    x: Math.cos(xAxisRotationRadians) * ellipseComponentX - Math.sin(xAxisRotationRadians) * ellipseComponentY + center.x,\n    y: Math.sin(xAxisRotationRadians) * ellipseComponentX + Math.cos(xAxisRotationRadians) * ellipseComponentY + center.y,\n    ellipticalArcStartAngle: startAngle,\n    ellipticalArcEndAngle: startAngle + sweepAngle,\n    ellipticalArcAngle: angle,\n    ellipticalArcCenter: center,\n    resultantRx: rx,\n    resultantRy: ry\n  };\n  return point;\n};\nvar approximateArcLengthOfCurve = (resolution, pointOnCurveFunc) => {\n  resolution = resolution ? resolution : 500;\n  let resultantArcLength = 0;\n  const arcLengthMap = [];\n  const approximationLines = [];\n  let prevPoint = pointOnCurveFunc(0);\n  let nextPoint;\n  for (let i = 0;i < resolution; i++) {\n    const t = clamp(i * (1 / resolution), 0, 1);\n    nextPoint = pointOnCurveFunc(t);\n    resultantArcLength += distance(prevPoint, nextPoint);\n    approximationLines.push([prevPoint, nextPoint]);\n    arcLengthMap.push({\n      t,\n      arcLength: resultantArcLength\n    });\n    prevPoint = nextPoint;\n  }\n  nextPoint = pointOnCurveFunc(1);\n  approximationLines.push([prevPoint, nextPoint]);\n  resultantArcLength += distance(prevPoint, nextPoint);\n  arcLengthMap.push({\n    t: 1,\n    arcLength: resultantArcLength\n  });\n  return {\n    arcLength: resultantArcLength,\n    arcLengthMap,\n    approximationLines\n  };\n};\nvar makeArc = ({\n  x0,\n  y0,\n  rx,\n  ry,\n  xAxisRotate,\n  LargeArcFlag,\n  SweepFlag,\n  x1,\n  y1\n}) => {\n  const lengthProperties = approximateArcLengthOfCurve(300, (t) => {\n    return pointOnEllipticalArc({\n      p0: { x: x0, y: y0 },\n      rx,\n      ry,\n      xAxisRotation: xAxisRotate,\n      largeArcFlag: LargeArcFlag,\n      sweepFlag: SweepFlag,\n      p1: { x: x1, y: y1 },\n      t\n    });\n  });\n  const length2 = lengthProperties.arcLength;\n  const getPointAtLength = (fractionLength) => {\n    if (fractionLength < 0) {\n      fractionLength = 0;\n    } else if (fractionLength > length2) {\n      fractionLength = length2;\n    }\n    const position = pointOnEllipticalArc({\n      p0: { x: x0, y: y0 },\n      rx,\n      ry,\n      xAxisRotation: xAxisRotate,\n      largeArcFlag: LargeArcFlag,\n      sweepFlag: SweepFlag,\n      p1: { x: x1, y: y1 },\n      t: fractionLength / length2\n    });\n    return { x: position.x, y: position.y };\n  };\n  return {\n    getPointAtLength,\n    getTangentAtLength: (fractionLength) => {\n      if (fractionLength < 0) {\n        fractionLength = 0;\n      } else if (fractionLength > length2) {\n        fractionLength = length2;\n      }\n      const point_dist = 0.05;\n      const p1 = getPointAtLength(fractionLength);\n      let p2;\n      if (fractionLength < 0) {\n        fractionLength = 0;\n      } else if (fractionLength > length2) {\n        fractionLength = length2;\n      }\n      if (fractionLength < length2 - point_dist) {\n        p2 = getPointAtLength(fractionLength + point_dist);\n      } else {\n        p2 = getPointAtLength(fractionLength - point_dist);\n      }\n      const xDist = p2.x - p1.x;\n      const yDist = p2.y - p1.y;\n      const dist = Math.sqrt(xDist * xDist + yDist * yDist);\n      if (fractionLength < length2 - point_dist) {\n        return { x: -xDist / dist, y: -yDist / dist };\n      }\n      return { x: xDist / dist, y: yDist / dist };\n    },\n    getTotalLength: () => {\n      return length2;\n    },\n    type: \"arc\"\n  };\n};\n\n// src/helpers/construct.ts\nvar constructFromInstructions = (instructions) => {\n  let totalLength = 0;\n  const partialLengths = [];\n  const functions = [];\n  let initialPoint = null;\n  let cur = [0, 0];\n  let prev_point = [0, 0];\n  let curve;\n  let ringStart = [0, 0];\n  const segments = [];\n  for (let i = 0;i < instructions.length; i++) {\n    const instruction = instructions[i];\n    if (instruction.type !== \"m\" && instruction.type !== \"M\" && segments.length > 0) {\n      segments[segments.length - 1].push(instruction);\n    }\n    if (instruction.type === \"M\") {\n      cur = [instruction.x, instruction.y];\n      ringStart = [cur[0], cur[1]];\n      segments.push([instruction]);\n      functions.push(null);\n      if (i === 0) {\n        initialPoint = { x: instruction.x, y: instruction.y };\n      }\n    }\n    if (instruction.type === \"m\") {\n      cur = [instruction.dx + cur[0], instruction.dy + cur[1]];\n      ringStart = [cur[0], cur[1]];\n      segments.push([{ type: \"M\", x: cur[0], y: cur[1] }]);\n      functions.push(null);\n    }\n    if (instruction.type === \"L\") {\n      totalLength += Math.sqrt((cur[0] - instruction.x) ** 2 + (cur[1] - instruction.y) ** 2);\n      functions.push(makeLinearPosition({\n        x0: cur[0],\n        x1: instruction.x,\n        y0: cur[1],\n        y1: instruction.y\n      }));\n      cur = [instruction.x, instruction.y];\n    }\n    if (instruction.type === \"l\") {\n      totalLength += Math.sqrt(instruction.dx ** 2 + instruction.dy ** 2);\n      functions.push(makeLinearPosition({\n        x0: cur[0],\n        x1: instruction.dx + cur[0],\n        y0: cur[1],\n        y1: instruction.dy + cur[1]\n      }));\n      cur = [instruction.dx + cur[0], instruction.dy + cur[1]];\n    }\n    if (instruction.type === \"H\") {\n      totalLength += Math.abs(cur[0] - instruction.x);\n      functions.push(makeLinearPosition({\n        x0: cur[0],\n        x1: instruction.x,\n        y0: cur[1],\n        y1: cur[1]\n      }));\n      cur[0] = instruction.x;\n    }\n    if (instruction.type === \"h\") {\n      totalLength += Math.abs(instruction.dx);\n      functions.push(makeLinearPosition({\n        x0: cur[0],\n        x1: cur[0] + instruction.dx,\n        y0: cur[1],\n        y1: cur[1]\n      }));\n      cur[0] = instruction.dx + cur[0];\n    } else if (instruction.type === \"V\") {\n      totalLength += Math.abs(cur[1] - instruction.y);\n      functions.push(makeLinearPosition({\n        x0: cur[0],\n        x1: cur[0],\n        y0: cur[1],\n        y1: instruction.y\n      }));\n      cur[1] = instruction.y;\n    }\n    if (instruction.type === \"v\") {\n      totalLength += Math.abs(instruction.dy);\n      functions.push(makeLinearPosition({\n        x0: cur[0],\n        x1: cur[0],\n        y0: cur[1],\n        y1: cur[1] + instruction.dy\n      }));\n      cur[1] = instruction.dy + cur[1];\n    } else if (instruction.type === \"Z\") {\n      totalLength += Math.sqrt((ringStart[0] - cur[0]) ** 2 + (ringStart[1] - cur[1]) ** 2);\n      functions.push(makeLinearPosition({\n        x0: cur[0],\n        x1: ringStart[0],\n        y0: cur[1],\n        y1: ringStart[1]\n      }));\n      cur = [ringStart[0], ringStart[1]];\n    }\n    if (instruction.type === \"C\") {\n      curve = makeCubic({\n        startX: cur[0],\n        startY: cur[1],\n        cp1x: instruction.cp1x,\n        cp1y: instruction.cp1y,\n        cp2x: instruction.cp2x,\n        cp2y: instruction.cp2y,\n        x: instruction.x,\n        y: instruction.y\n      });\n      totalLength += curve.getTotalLength();\n      cur = [instruction.x, instruction.y];\n      functions.push(curve);\n    } else if (instruction.type === \"c\") {\n      curve = makeCubic({\n        startX: cur[0],\n        startY: cur[1],\n        cp1x: cur[0] + instruction.cp1dx,\n        cp1y: cur[1] + instruction.cp1dy,\n        cp2x: cur[0] + instruction.cp2dx,\n        cp2y: cur[1] + instruction.cp2dy,\n        x: cur[0] + instruction.dx,\n        y: cur[1] + instruction.dy\n      });\n      if (curve.getTotalLength() > 0) {\n        totalLength += curve.getTotalLength();\n        functions.push(curve);\n        cur = [instruction.dx + cur[0], instruction.dy + cur[1]];\n      } else {\n        functions.push(makeLinearPosition({ x0: cur[0], x1: cur[0], y0: cur[1], y1: cur[1] }));\n      }\n    }\n    if (instruction.type === \"S\") {\n      const prev = instructions[i - 1];\n      const prevWasCurve = prev.type === \"C\" || prev.type === \"c\" || prev.type === \"S\" || prev.type === \"s\";\n      if (i > 0 && prevWasCurve) {\n        if (curve) {\n          const c = curve.getC();\n          curve = makeCubic({\n            startX: cur[0],\n            startY: cur[1],\n            cp1x: 2 * cur[0] - c.x,\n            cp1y: 2 * cur[1] - c.y,\n            cp2x: instruction.cpx,\n            cp2y: instruction.cpy,\n            x: instruction.x,\n            y: instruction.y\n          });\n        }\n      } else {\n        curve = makeCubic({\n          startX: cur[0],\n          startY: cur[1],\n          cp1x: cur[0],\n          cp1y: cur[1],\n          cp2x: instruction.cpx,\n          cp2y: instruction.cpy,\n          x: instruction.x,\n          y: instruction.y\n        });\n      }\n      if (curve) {\n        totalLength += curve.getTotalLength();\n        cur = [instruction.x, instruction.y];\n        functions.push(curve);\n      }\n    }\n    if (instruction.type === \"s\") {\n      const prev = instructions[i - 1];\n      const prevWasCurve = prev.type === \"C\" || prev.type === \"c\" || prev.type === \"S\" || prev.type === \"s\";\n      if (i > 0 && prevWasCurve) {\n        if (curve) {\n          const c = curve.getC();\n          const d = curve.getD();\n          curve = makeCubic({\n            startX: cur[0],\n            startY: cur[1],\n            cp1x: cur[0] + d.x - c.x,\n            cp1y: cur[1] + d.y - c.y,\n            cp2x: cur[0] + instruction.cpdx,\n            cp2y: cur[1] + instruction.cpdy,\n            x: cur[0] + instruction.dx,\n            y: cur[1] + instruction.dy\n          });\n        }\n      } else {\n        curve = makeCubic({\n          startX: cur[0],\n          startY: cur[1],\n          cp1x: cur[0],\n          cp1y: cur[1],\n          cp2x: cur[0] + instruction.cpdx,\n          cp2y: cur[1] + instruction.cpdy,\n          x: cur[0] + instruction.dx,\n          y: cur[1] + instruction.dy\n        });\n      }\n      if (curve) {\n        totalLength += curve.getTotalLength();\n        cur = [instruction.dx + cur[0], instruction.dy + cur[1]];\n        functions.push(curve);\n      }\n    }\n    if (instruction.type === \"Q\") {\n      if (cur[0] === instruction.cpx && cur[1] === instruction.cpy) {\n        const linearCurve = makeLinearPosition({\n          x0: instruction.cpx,\n          x1: instruction.x,\n          y0: instruction.cpy,\n          y1: instruction.y\n        });\n        totalLength += linearCurve.getTotalLength();\n        functions.push(linearCurve);\n      } else {\n        curve = makeQuadratic({\n          startX: cur[0],\n          startY: cur[1],\n          cpx: instruction.cpx,\n          cpy: instruction.cpy,\n          x: instruction.x,\n          y: instruction.y\n        });\n        totalLength += curve.getTotalLength();\n        functions.push(curve);\n      }\n      cur = [instruction.x, instruction.y];\n      prev_point = [instruction.cpx, instruction.cpy];\n    }\n    if (instruction.type === \"q\") {\n      if (instruction.cpdx === 0 && instruction.cpdy === 0) {\n        const linearCurve = makeLinearPosition({\n          x0: cur[0] + instruction.cpdx,\n          x1: cur[0] + instruction.cpdy,\n          y0: cur[1] + instruction.dx,\n          y1: cur[1] + instruction.dy\n        });\n        totalLength += linearCurve.getTotalLength();\n        functions.push(linearCurve);\n      } else {\n        curve = makeQuadratic({\n          startX: cur[0],\n          startY: cur[1],\n          cpx: cur[0] + instruction.cpdx,\n          cpy: cur[1] + instruction.cpdy,\n          x: cur[0] + instruction.dx,\n          y: cur[1] + instruction.dy\n        });\n        totalLength += curve.getTotalLength();\n        functions.push(curve);\n      }\n      prev_point = [cur[0] + instruction.cpdx, cur[1] + instruction.cpdy];\n      cur = [instruction.dx + cur[0], instruction.dy + cur[1]];\n    }\n    if (instruction.type === \"T\") {\n      const prev = instructions[i - 1];\n      const prevWasQ = prev.type === \"Q\" || prev.type === \"q\" || prev.type === \"T\" || prev.type === \"t\";\n      if (i > 0 && prevWasQ) {\n        curve = makeQuadratic({\n          startX: cur[0],\n          startY: cur[1],\n          cpx: 2 * cur[0] - prev_point[0],\n          cpy: 2 * cur[1] - prev_point[1],\n          x: instruction.x,\n          y: instruction.y\n        });\n        functions.push(curve);\n        totalLength += curve.getTotalLength();\n      } else {\n        const linearCurve = makeLinearPosition({\n          x0: cur[0],\n          x1: instruction.x,\n          y0: cur[1],\n          y1: instruction.y\n        });\n        functions.push(linearCurve);\n        totalLength += linearCurve.getTotalLength();\n      }\n      prev_point = [2 * cur[0] - prev_point[0], 2 * cur[1] - prev_point[1]];\n      cur = [instruction.x, instruction.y];\n    }\n    if (instruction.type === \"t\") {\n      const prev = instructions[i - 1];\n      const prevWasQ = prev.type === \"Q\" || prev.type === \"q\" || prev.type === \"T\" || prev.type === \"t\";\n      if (i > 0 && prevWasQ) {\n        curve = makeQuadratic({\n          startX: cur[0],\n          startY: cur[1],\n          cpx: 2 * cur[0] - prev_point[0],\n          cpy: 2 * cur[1] - prev_point[1],\n          x: cur[0] + instruction.dx,\n          y: cur[1] + instruction.dy\n        });\n        totalLength += curve.getTotalLength();\n        functions.push(curve);\n      } else {\n        const linearCurve = makeLinearPosition({\n          x0: cur[0],\n          x1: cur[0] + instruction.dx,\n          y0: cur[1],\n          y1: cur[1] + instruction.dy\n        });\n        totalLength += linearCurve.getTotalLength();\n        functions.push(linearCurve);\n      }\n      prev_point = [2 * cur[0] - prev_point[0], 2 * cur[1] - prev_point[1]];\n      cur = [instruction.dx + cur[0], instruction.dy + cur[1]];\n    }\n    if (instruction.type === \"A\") {\n      const arcCurve = makeArc({\n        x0: cur[0],\n        y0: cur[1],\n        rx: instruction.rx,\n        ry: instruction.ry,\n        xAxisRotate: instruction.xAxisRotation,\n        LargeArcFlag: instruction.largeArcFlag,\n        SweepFlag: instruction.sweepFlag,\n        x1: instruction.x,\n        y1: instruction.y\n      });\n      totalLength += arcCurve.getTotalLength();\n      cur = [instruction.x, instruction.y];\n      functions.push(arcCurve);\n    }\n    if (instruction.type === \"a\") {\n      const arcCurve = makeArc({\n        x0: cur[0],\n        y0: cur[1],\n        rx: instruction.rx,\n        ry: instruction.ry,\n        xAxisRotate: instruction.xAxisRotation,\n        LargeArcFlag: instruction.largeArcFlag,\n        SweepFlag: instruction.sweepFlag,\n        x1: cur[0] + instruction.dx,\n        y1: cur[1] + instruction.dy\n      });\n      totalLength += arcCurve.getTotalLength();\n      cur = [cur[0] + instruction.dx, cur[1] + instruction.dy];\n      functions.push(arcCurve);\n    }\n    partialLengths.push(totalLength);\n  }\n  return {\n    segments,\n    initialPoint,\n    totalLength,\n    partialLengths,\n    functions\n  };\n};\nvar construct = (string) => {\n  const parsed = parsePath(string);\n  return constructFromInstructions(parsed);\n};\n\n// src/get-length.ts\nvar getLength = (path) => {\n  const constructucted = construct(path);\n  return constructucted.totalLength;\n};\n\n// src/evolve-path.ts\nvar evolvePath = (progress, path) => {\n  const length2 = getLength(path);\n  if (progress === 0) {\n    const extendedLength = length2 * 1.5;\n    return {\n      strokeDasharray: `${extendedLength} ${extendedLength}`,\n      strokeDashoffset: extendedLength\n    };\n  }\n  const strokeDasharray = `${length2} ${length2}`;\n  const strokeDashoffset = length2 - progress * length2;\n  return { strokeDasharray, strokeDashoffset };\n};\n// src/extend-viewbox.ts\nvar extendViewBox = (currentViewBox, scale) => {\n  const relativeScale = scale - 1;\n  const splitted = currentViewBox.split(\" \").map((a) => a.trim()).filter((a) => a !== \"\").map(Number);\n  if (splitted.length !== 4) {\n    throw new Error(`currentViewBox must be 4 valid numbers, but got \"${currentViewBox}\"`);\n  }\n  for (const part of splitted) {\n    if (Number.isNaN(part)) {\n      throw new Error(`currentViewBox must be 4 valid numbers, but got \"${currentViewBox}\"`);\n    }\n    if (!Number.isFinite(part)) {\n      throw new Error(`currentViewBox must be 4 valid numbers, but got \"${currentViewBox}\"`);\n    }\n  }\n  const [x, y, width, height] = splitted;\n  return [\n    x - relativeScale * width / 2,\n    y - relativeScale * height / 2,\n    width + relativeScale * width,\n    height + relativeScale * height\n  ].join(\" \");\n};\n// src/get-instruction-index-at-length.ts\nvar getInstructionIndexAtLengthFromConstructed = (constructed, fractionLength) => {\n  if (fractionLength < 0) {\n    throw new Error(\"Length less than 0 was passed\");\n  }\n  if (fractionLength > constructed.totalLength) {\n    fractionLength = constructed.totalLength;\n  }\n  let index = constructed.partialLengths.length - 1;\n  while (constructed.partialLengths[index] >= fractionLength && index > 0) {\n    index--;\n  }\n  return {\n    lengthIntoInstruction: fractionLength - constructed.partialLengths[index],\n    index\n  };\n};\nvar getInstructionIndexAtLength = (path, length2) => {\n  const constructed = construct(path);\n  if (length2 > constructed.totalLength) {\n    throw new Error(`A length of ${length2} was passed to getInstructionIndexAtLength() but the total length of the path is only ${constructed.totalLength}`);\n  }\n  return getInstructionIndexAtLengthFromConstructed(constructed, length2);\n};\n// src/get-point-at-length.ts\nvar getPointAtLength = (path, length2) => {\n  const constructed = construct(path);\n  const fractionPart = getInstructionIndexAtLengthFromConstructed(constructed, length2);\n  const functionAtPart = constructed.functions[fractionPart.index + 1];\n  if (functionAtPart) {\n    return functionAtPart.getPointAtLength(fractionPart.lengthIntoInstruction);\n  }\n  if (constructed.initialPoint) {\n    return constructed.initialPoint;\n  }\n  throw new Error(\"Wrong function at this part.\");\n};\n// src/get-subpaths.ts\nvar getSubpaths = (path) => {\n  const parsed = parsePath(path);\n  const { segments } = constructFromInstructions(parsed);\n  return segments.map((seg) => {\n    return serializeInstructions(seg);\n  });\n};\n// src/get-tangent-at-length.ts\nvar getTangentAtLength = (path, length2) => {\n  const constructed = construct(path);\n  const fractionPart = getInstructionIndexAtLengthFromConstructed(constructed, length2);\n  const functionAtPart = constructed.functions[fractionPart.index + 1];\n  if (functionAtPart) {\n    return functionAtPart.getTangentAtLength(fractionPart.lengthIntoInstruction);\n  }\n  if (constructed.initialPoint) {\n    return { x: 0, y: 0 };\n  }\n  throw new Error(\"Wrong function at this part.\");\n};\n// src/get-end-position.ts\nvar getEndPosition = (instructions) => {\n  let x = 0;\n  let y = 0;\n  let moveX = 0;\n  let moveY = 0;\n  for (let i = 0;i < instructions.length; i++) {\n    const instruction = instructions[i];\n    if (instruction.type === \"M\") {\n      moveX = instruction.x;\n      moveY = instruction.y;\n    } else if (instruction.type === \"m\") {\n      moveX += instruction.dx;\n      moveY += instruction.dy;\n    }\n    if (instruction.type === \"A\" || instruction.type === \"C\" || instruction.type === \"L\" || instruction.type === \"M\" || instruction.type === \"Q\" || instruction.type === \"S\" || instruction.type === \"T\") {\n      x = instruction.x;\n      y = instruction.y;\n      continue;\n    }\n    if (instruction.type === \"a\" || instruction.type === \"c\" || instruction.type === \"l\" || instruction.type === \"m\" || instruction.type === \"q\" || instruction.type === \"s\" || instruction.type === \"t\") {\n      x += instruction.dx;\n      y += instruction.dy;\n      continue;\n    }\n    if (instruction.type === \"H\") {\n      x = instruction.x;\n      continue;\n    }\n    if (instruction.type === \"V\") {\n      y = instruction.y;\n      continue;\n    }\n    if (instruction.type === \"Z\") {\n      x = moveX;\n      y = moveY;\n      continue;\n    }\n    if (instruction.type === \"h\") {\n      x += instruction.dx;\n      continue;\n    }\n    if (instruction.type === \"v\") {\n      y += instruction.dy;\n      continue;\n    }\n    throw new Error(\"Unknown instruction type: \" + instruction.type);\n  }\n  return {\n    x,\n    y\n  };\n};\n\n// src/interpolate-path/convert-to-same-instruction-type.ts\nvar convertToLCommand = (command) => {\n  if (command.type === \"M\" || command.type === \"L\" || command.type === \"Z\") {\n    throw new Error(\"unexpected\");\n  }\n  return {\n    type: \"L\",\n    x: command.x,\n    y: command.y\n  };\n};\nvar convertToCCommand = (command, currentPoint) => {\n  if (command.type === \"M\" || command.type === \"C\" || command.type === \"Z\") {\n    throw new Error(\"unexpected\");\n  }\n  if (command.type === \"L\") {\n    return {\n      type: \"C\",\n      cp1x: currentPoint.x,\n      cp1y: currentPoint.y,\n      cp2x: command.x,\n      cp2y: command.y,\n      x: command.x,\n      y: command.y\n    };\n  }\n  throw new Error(\"all types should be handled\");\n};\nfunction convertToSameInstructionType(aCommand, bCommand, currentPoint) {\n  if (aCommand.type === \"M\" || bCommand.type === \"M\") {\n    return { ...aCommand };\n  }\n  if (aCommand.type === bCommand.type) {\n    return { ...aCommand };\n  }\n  if (bCommand.type === \"C\") {\n    return convertToCCommand(aCommand, currentPoint);\n  }\n  if (bCommand.type === \"L\") {\n    return convertToLCommand(aCommand);\n  }\n  if (bCommand.type === \"Z\") {\n    return {\n      type: \"Z\"\n    };\n  }\n  throw new TypeError(\"unhandled\");\n}\n\n// src/interpolate-path/points-to-command.ts\nfunction pointsToInstruction(points) {\n  const x = points[points.length - 1][0];\n  const y = points[points.length - 1][1];\n  if (points.length === 4) {\n    const x1 = points[1][0];\n    const y1 = points[1][1];\n    const x2 = points[2][0];\n    const y2 = points[2][1];\n    return {\n      type: \"C\",\n      cp1x: x1,\n      cp1y: y1,\n      cp2x: x2,\n      cp2y: y2,\n      x,\n      y\n    };\n  }\n  if (points.length === 3) {\n    const x1 = points[1][0];\n    const y1 = points[1][1];\n    return convertQToCInstruction({\n      type: \"Q\",\n      cpx: x1,\n      cpy: y1,\n      x,\n      y\n    }, {\n      x: points[0][0],\n      y: points[0][1]\n    });\n  }\n  return {\n    type: \"L\",\n    x,\n    y\n  };\n}\n\n// src/interpolate-path/de-casteljau.ts\nfunction decasteljau(points, t) {\n  const left = [];\n  const right = [];\n  function decasteljauRecurse(_points, _t) {\n    if (_points.length === 1) {\n      left.push(_points[0]);\n      right.push(_points[0]);\n    } else {\n      const newPoints = Array(_points.length - 1);\n      for (let i = 0;i < newPoints.length; i++) {\n        if (i === 0) {\n          left.push(_points[0]);\n        }\n        if (i === newPoints.length - 1) {\n          right.push(_points[i + 1]);\n        }\n        newPoints[i] = [\n          (1 - _t) * _points[i][0] + _t * _points[i + 1][0],\n          (1 - _t) * _points[i][1] + _t * _points[i + 1][1]\n        ];\n      }\n      decasteljauRecurse(newPoints, _t);\n    }\n  }\n  if (points.length) {\n    decasteljauRecurse(points, t);\n  }\n  return { left, right: right.reverse() };\n}\n\n// src/interpolate-path/split-curve-as-points.ts\nfunction splitCurveAsPoints(points, segmentCount = 2) {\n  const segments = [];\n  let remainingCurve = points;\n  const tIncrement = 1 / segmentCount;\n  for (let i = 0;i < segmentCount - 1; i++) {\n    const tRelative = tIncrement / (1 - tIncrement * i);\n    const split = decasteljau(remainingCurve, tRelative);\n    segments.push(split.left);\n    remainingCurve = split.right;\n  }\n  segments.push(remainingCurve);\n  return segments;\n}\n\n// src/interpolate-path/split-curve.ts\nvar splitCurveInstructions = (instructionStartX, instructionStartY, instructionEnd, segmentCount) => {\n  const points = [[instructionStartX, instructionStartY]];\n  if (instructionEnd.type === \"Q\") {\n    points.push([instructionEnd.cpx, instructionEnd.cpy]);\n  }\n  if (instructionEnd.type === \"C\") {\n    points.push([instructionEnd.cp1x, instructionEnd.cp1y]);\n    points.push([instructionEnd.cp2x, instructionEnd.cp2y]);\n  }\n  points.push([instructionEnd.x, instructionEnd.y]);\n  return splitCurveAsPoints(points, segmentCount).map((p) => {\n    return pointsToInstruction(p);\n  });\n};\n\n// src/interpolate-path/split-segment.ts\nfunction splitSegmentInstructions(commandStart, commandEnd, segmentCount) {\n  let segments = [];\n  if (commandEnd.type === \"L\" || commandEnd.type === \"C\") {\n    if (commandStart.type !== \"Z\") {\n      segments = segments.concat(splitCurveInstructions(commandStart.x, commandStart.y, commandEnd, segmentCount));\n    }\n  } else {\n    const copyCommand = commandStart.type === \"M\" ? {\n      type: \"L\",\n      x: commandStart.x,\n      y: commandStart.y\n    } : commandStart;\n    segments = segments.concat(new Array(segmentCount - 1).fill(true).map(() => copyCommand));\n    segments.push(commandEnd);\n  }\n  return segments;\n}\n\n// src/interpolate-path/extend-command.ts\nfunction extendInstruction(commandsToExtend, referenceCommands) {\n  const numSegmentsToExtend = commandsToExtend.length - 1;\n  const numReferenceSegments = referenceCommands.length - 1;\n  const segmentRatio = numSegmentsToExtend / numReferenceSegments;\n  const countPointsPerSegment = new Array(numReferenceSegments).fill(undefined).reduce((accum, _d, i) => {\n    const insertIndex = Math.floor(segmentRatio * i);\n    accum[insertIndex] = (accum[insertIndex] || 0) + 1;\n    return accum;\n  }, []);\n  const extended = countPointsPerSegment.reduce((_extended, segmentCount, i) => {\n    if (i === commandsToExtend.length - 1) {\n      const lastCommandCopies = new Array(segmentCount).fill({\n        ...commandsToExtend[commandsToExtend.length - 1]\n      });\n      if (lastCommandCopies[0].type === \"M\") {\n        lastCommandCopies.forEach((d) => {\n          d.type = \"L\";\n        });\n      }\n      return _extended.concat(lastCommandCopies);\n    }\n    return _extended.concat(splitSegmentInstructions(commandsToExtend[i], commandsToExtend[i + 1], segmentCount));\n  }, []);\n  extended.unshift(commandsToExtend[0]);\n  return extended;\n}\n\n// src/interpolate-path/interpolate-instruction-of-same-kind.ts\nvar interpolateLInstruction = (t, first, second) => {\n  return {\n    type: \"L\",\n    x: (1 - t) * first.x + t * second.x,\n    y: (1 - t) * first.y + t * second.y\n  };\n};\nvar interpolateCInstructions = (t, first, second) => {\n  return {\n    type: \"C\",\n    cp1x: (1 - t) * first.cp1x + t * second.cp1x,\n    cp2x: (1 - t) * first.cp2x + t * second.cp2x,\n    cp1y: (1 - t) * first.cp1y + t * second.cp1y,\n    cp2y: (1 - t) * first.cp2y + t * second.cp2y,\n    x: (1 - t) * first.x + t * second.x,\n    y: (1 - t) * first.y + t * second.y\n  };\n};\nvar interpolateMInstructions = (t, first, second) => {\n  return {\n    type: \"M\",\n    x: (1 - t) * first.x + t * second.x,\n    y: (1 - t) * first.y + t * second.y\n  };\n};\nvar interpolateInstructionOfSameKind = (t, first, second) => {\n  if (first.type === \"L\") {\n    if (second.type !== \"L\") {\n      throw new Error(\"mismatch\");\n    }\n    return interpolateLInstruction(t, first, second);\n  }\n  if (first.type === \"C\") {\n    if (second.type !== \"C\") {\n      throw new Error(\"mismatch\");\n    }\n    return interpolateCInstructions(t, first, second);\n  }\n  if (first.type === \"M\") {\n    if (second.type !== \"M\") {\n      throw new Error(\"mismatch\");\n    }\n    return interpolateMInstructions(t, first, second);\n  }\n  if (first.type === \"Z\") {\n    if (second.type !== \"Z\") {\n      throw new Error(\"mismatch\");\n    }\n    return {\n      type: \"Z\"\n    };\n  }\n  throw new Error(\"mismatch\");\n};\n\n// src/interpolate-path/interpolate-instructions.ts\nfunction interpolateInstructions(aCommandsInput, bCommandsInput) {\n  let aCommands = aCommandsInput.slice();\n  let bCommands = bCommandsInput.slice();\n  if (!aCommands.length && !bCommands.length) {\n    return function() {\n      return [];\n    };\n  }\n  const addZ = (aCommands.length === 0 || aCommands[aCommands.length - 1].type === \"Z\") && (bCommands.length === 0 || bCommands[bCommands.length - 1].type === \"Z\");\n  if (aCommands.length > 0 && aCommands[aCommands.length - 1].type === \"Z\") {\n    aCommands.pop();\n  }\n  if (bCommands.length > 0 && bCommands[bCommands.length - 1].type === \"Z\") {\n    bCommands.pop();\n  }\n  if (!aCommands.length) {\n    aCommands.push(bCommands[0]);\n  } else if (!bCommands.length) {\n    bCommands.push(aCommands[0]);\n  }\n  const numPointsToExtend = Math.abs(bCommands.length - aCommands.length);\n  if (numPointsToExtend !== 0) {\n    if (bCommands.length > aCommands.length) {\n      aCommands = extendInstruction(aCommands, bCommands);\n    } else if (bCommands.length < aCommands.length) {\n      bCommands = extendInstruction(bCommands, aCommands);\n    }\n  }\n  const aSameType = aCommands.map((aCommand, i) => {\n    const commandsUntilNow = aCommands.slice(0, i);\n    const point = getEndPosition(commandsUntilNow);\n    return convertToSameInstructionType(aCommand, bCommands[i], point);\n  });\n  const interpolatedCommands = [];\n  if (addZ) {\n    aSameType.push({ type: \"Z\" });\n    bCommands.push({ type: \"Z\" });\n  }\n  return function(t) {\n    if (t === 1) {\n      return bCommandsInput;\n    }\n    if (t === 0) {\n      return aSameType;\n    }\n    for (let i = 0;i < aSameType.length; ++i) {\n      interpolatedCommands.push(interpolateInstructionOfSameKind(t, aSameType[i], bCommands[i]));\n    }\n    return interpolatedCommands;\n  };\n}\n\n// src/interpolate-path/interpolate-path.ts\nvar interpolatePath = (value, firstPath, secondPath) => {\n  if (value === 1) {\n    return secondPath;\n  }\n  if (value === 0) {\n    return firstPath;\n  }\n  const aCommands = reduceInstructions(parsePath(firstPath));\n  if (aCommands.length === 0) {\n    throw new TypeError(`SVG Path \"${firstPath}\" is not valid`);\n  }\n  const bCommands = reduceInstructions(parsePath(secondPath));\n  if (bCommands.length === 0) {\n    throw new TypeError(`SVG Path \"${secondPath}\" is not valid`);\n  }\n  const commandInterpolator = interpolateInstructions(aCommands, bCommands);\n  return serializeInstructions(commandInterpolator(value));\n};\n// src/translate-path.ts\nvar translateSegments = (segments, x, y) => {\n  return segments.map((segment) => {\n    if (segment.type === \"a\" || segment.type === \"c\" || segment.type === \"v\" || segment.type === \"s\" || segment.type === \"h\" || segment.type === \"l\" || segment.type === \"m\" || segment.type === \"q\" || segment.type === \"t\") {\n      return segment;\n    }\n    if (segment.type === \"V\") {\n      return {\n        type: \"V\",\n        y: segment.y + y\n      };\n    }\n    if (segment.type === \"H\") {\n      return {\n        type: \"H\",\n        x: segment.x + x\n      };\n    }\n    if (segment.type === \"A\") {\n      return {\n        type: \"A\",\n        rx: segment.rx,\n        ry: segment.ry,\n        largeArcFlag: segment.largeArcFlag,\n        sweepFlag: segment.sweepFlag,\n        xAxisRotation: segment.xAxisRotation,\n        x: segment.x + x,\n        y: segment.y + y\n      };\n    }\n    if (segment.type === \"Z\") {\n      return segment;\n    }\n    if (segment.type === \"C\") {\n      return {\n        type: \"C\",\n        cp1x: segment.cp1x + x,\n        cp1y: segment.cp1y + y,\n        cp2x: segment.cp2x + x,\n        cp2y: segment.cp2y + y,\n        x: segment.x + x,\n        y: segment.y + y\n      };\n    }\n    if (segment.type === \"Q\") {\n      return {\n        type: \"Q\",\n        cpx: segment.cpx + x,\n        cpy: segment.cpy + y,\n        x: segment.x + x,\n        y: segment.y + y\n      };\n    }\n    if (segment.type === \"S\") {\n      return {\n        type: \"S\",\n        cpx: segment.cpx + x,\n        cpy: segment.cpy + y,\n        x: segment.x + x,\n        y: segment.y + y\n      };\n    }\n    if (segment.type === \"T\") {\n      return {\n        type: \"T\",\n        x: segment.x + x,\n        y: segment.y + y\n      };\n    }\n    if (segment.type === \"L\") {\n      return {\n        type: \"L\",\n        x: segment.x + x,\n        y: segment.y + y\n      };\n    }\n    if (segment.type === \"M\") {\n      return {\n        type: \"M\",\n        x: segment.x + x,\n        y: segment.y + y\n      };\n    }\n    throw new Error(`Unknown segment type: ${segment.type}`);\n  });\n};\nvar translatePath = (path, x, y) => {\n  return serializeInstructions(translateSegments(parsePath(path), x, y));\n};\n\n// src/reset-path.ts\nvar resetPath = (d) => {\n  const box = getBoundingBox(d);\n  return translatePath(d, -box.x1, -box.y1);\n};\n// src/reverse-path.ts\nfunction reverseNormalizedPath(instructions) {\n  const reversed = [];\n  let nextX = 0;\n  let nextY = 0;\n  for (const term of instructions) {\n    if (term.type === \"A\") {\n      reversed.unshift({\n        type: \"A\",\n        largeArcFlag: term.largeArcFlag,\n        rx: term.rx,\n        ry: term.ry,\n        xAxisRotation: term.xAxisRotation,\n        sweepFlag: !term.sweepFlag,\n        x: nextX,\n        y: nextY\n      });\n    } else if (term.type === \"C\") {\n      reversed.unshift({\n        type: \"C\",\n        cp1x: term.cp2x,\n        cp1y: term.cp2y,\n        cp2x: term.cp1x,\n        cp2y: term.cp1y,\n        x: nextX,\n        y: nextY\n      });\n    } else if (term.type === \"Q\") {\n      reversed.unshift({\n        type: \"Q\",\n        cpx: term.cpx,\n        cpy: term.cpy,\n        x: nextX,\n        y: nextY\n      });\n    } else if (term.type === \"L\") {\n      reversed.unshift({\n        type: \"L\",\n        x: nextX,\n        y: nextY\n      });\n    } else if (term.type === \"M\") {} else if (term.type === \"Z\") {} else {\n      throw new Error(\"unnormalized instruction \" + term.type);\n    }\n    if (term.type !== \"Z\") {\n      nextX = term.x;\n      nextY = term.y;\n    }\n  }\n  reversed.unshift({\n    type: \"M\",\n    x: nextX,\n    y: nextY\n  });\n  let revstring = serializeInstructions(reversed);\n  if (instructions[instructions.length - 1].type === \"Z\")\n    revstring += \"Z\";\n  revstring = revstring.replace(/M M/g, \"Z M\");\n  return revstring;\n}\nvar reversePath = (path) => {\n  const parsed = parsePath(path);\n  const normalized = normalizeInstructions(parsed);\n  const reduced = reduceInstructions(normalized);\n  const { segments } = constructFromInstructions(reduced);\n  return segments.map((spath) => {\n    return reverseNormalizedPath(spath);\n  }).join(\" \").replace(/ +/g, \" \").trim();\n};\n// src/scale-path.ts\nvar scalePath = (d, scaleX, scaleY) => {\n  const reduced = reduceInstructions(parsePath(d));\n  const bounded = getBoundingBoxFromInstructions(reduced);\n  const zeroed = translateSegments(reduced, -bounded.x1, -bounded.y1);\n  const mapped = zeroed.map((instruction) => {\n    if (instruction.type === \"L\") {\n      return {\n        type: \"L\",\n        x: scaleX * instruction.x,\n        y: scaleY * instruction.y\n      };\n    }\n    if (instruction.type === \"C\") {\n      return {\n        type: \"C\",\n        x: scaleX * instruction.x,\n        y: scaleY * instruction.y,\n        cp1x: scaleX * instruction.cp1x,\n        cp1y: scaleY * instruction.cp1y,\n        cp2x: scaleX * instruction.cp2x,\n        cp2y: scaleY * instruction.cp2y\n      };\n    }\n    if (instruction.type === \"M\") {\n      return {\n        type: \"M\",\n        x: scaleX * instruction.x,\n        y: scaleY * instruction.y\n      };\n    }\n    if (instruction.type === \"Q\") {\n      return {\n        type: \"Q\",\n        x: scaleX * instruction.x,\n        y: scaleY * instruction.y,\n        cpx: scaleX * instruction.cpx,\n        cpy: scaleY * instruction.cpy\n      };\n    }\n    if (instruction.type === \"Z\") {\n      return {\n        type: \"Z\"\n      };\n    }\n    if (instruction.type === \"A\") {\n      return {\n        type: \"A\",\n        largeArcFlag: instruction.largeArcFlag,\n        rx: scaleX * instruction.rx,\n        ry: scaleY * instruction.ry,\n        sweepFlag: instruction.sweepFlag,\n        xAxisRotation: instruction.xAxisRotation,\n        x: scaleX * instruction.x,\n        y: scaleY * instruction.y\n      };\n    }\n    if (instruction.type === \"H\") {\n      return {\n        type: \"H\",\n        x: scaleX * instruction.x\n      };\n    }\n    if (instruction.type === \"S\") {\n      return {\n        type: \"S\",\n        cpx: scaleX * instruction.cpx,\n        cpy: scaleY * instruction.cpy,\n        x: scaleX * instruction.x,\n        y: scaleY * instruction.y\n      };\n    }\n    if (instruction.type === \"T\") {\n      return {\n        type: \"T\",\n        x: scaleX * instruction.x,\n        y: scaleY * instruction.y\n      };\n    }\n    if (instruction.type === \"V\") {\n      return {\n        type: \"V\",\n        y: scaleY * instruction.y\n      };\n    }\n    if (instruction.type === \"a\") {\n      return {\n        type: \"a\",\n        dx: scaleX * instruction.dx,\n        dy: scaleY * instruction.dy,\n        largeArcFlag: instruction.largeArcFlag,\n        rx: scaleX * instruction.rx,\n        ry: scaleY * instruction.ry,\n        sweepFlag: instruction.sweepFlag,\n        xAxisRotation: instruction.xAxisRotation\n      };\n    }\n    if (instruction.type === \"c\") {\n      return {\n        type: \"c\",\n        cp1dx: scaleX * instruction.cp1dx,\n        cp1dy: scaleY * instruction.cp1dy,\n        cp2dx: scaleX * instruction.cp2dx,\n        cp2dy: scaleY * instruction.cp2dy,\n        dx: scaleX * instruction.dx,\n        dy: scaleY * instruction.dy\n      };\n    }\n    if (instruction.type === \"h\") {\n      return {\n        type: \"h\",\n        dx: scaleX * instruction.dx\n      };\n    }\n    if (instruction.type === \"l\") {\n      return {\n        type: \"l\",\n        dx: scaleX * instruction.dx,\n        dy: scaleY * instruction.dy\n      };\n    }\n    if (instruction.type === \"m\") {\n      return {\n        type: \"m\",\n        dx: scaleX * instruction.dx,\n        dy: scaleY * instruction.dy\n      };\n    }\n    if (instruction.type === \"q\") {\n      return {\n        type: \"q\",\n        cpdx: scaleX * instruction.cpdx,\n        cpdy: scaleY * instruction.cpdy,\n        dx: scaleX * instruction.dx,\n        dy: scaleY * instruction.dy\n      };\n    }\n    if (instruction.type === \"s\") {\n      return {\n        type: \"s\",\n        cpdx: scaleX * instruction.cpdx,\n        cpdy: scaleY * instruction.cpdy,\n        dx: scaleX * instruction.dx,\n        dy: scaleY * instruction.dy\n      };\n    }\n    if (instruction.type === \"t\") {\n      return {\n        type: \"t\",\n        dx: scaleX * instruction.dx,\n        dy: scaleY * instruction.dy\n      };\n    }\n    if (instruction.type === \"v\") {\n      return {\n        type: \"v\",\n        dy: scaleY * instruction.dy\n      };\n    }\n    throw new Error(\"unexpected function\");\n  });\n  return serializeInstructions(translateSegments(mapped, bounded.x1, bounded.y1));\n};\n// src/warp-path/warp-helpers.ts\nvar euclideanDistance = (points) => {\n  const startPoint = points[0];\n  const endPoint = points[points.length - 1];\n  let d2 = 0;\n  for (let i = 0;i < startPoint.length; i++) {\n    const d = endPoint[i] - startPoint[i];\n    d2 += d ** 2;\n  }\n  return Math.sqrt(d2);\n};\nfunction split(p, t = 0.5) {\n  const seg0 = [];\n  const seg1 = [];\n  const orders = [p];\n  while (orders.length < p.length) {\n    const q = orders[orders.length - 1];\n    const r = [];\n    for (let i = 1;i < q.length; i++) {\n      const q0 = q[i - 1];\n      const q1 = q[i];\n      const s = [];\n      const dim = Math.max(q0.length, q1.length);\n      for (let j = 0;j < dim; j++) {\n        const s0 = q0[j] || 0;\n        const s1 = q1[j] || 0;\n        s.push(s0 + (s1 - s0) * t);\n      }\n      r.push(s);\n    }\n    orders.push(r);\n  }\n  for (let i = 0;i < orders.length; i++) {\n    seg0.push(orders[i][0]);\n    seg1.push(orders[orders.length - 1 - i][i]);\n  }\n  return [seg0, seg1];\n}\nfunction interpolateUntil(points, threshold, deltaFunction = euclideanDistance) {\n  const stack = [points];\n  const segments = [];\n  while (stack.length > 0) {\n    const currentPoints = stack.pop();\n    if (deltaFunction(currentPoints) > threshold) {\n      const newPoints = split(currentPoints);\n      for (let i = newPoints.length - 1;i >= 0; i--) {\n        stack.push(newPoints[i]);\n      }\n    } else {\n      segments.push(currentPoints);\n    }\n  }\n  return segments;\n}\nfunction createLineSegment(points) {\n  switch (points.length) {\n    case 2:\n      return {\n        type: \"L\",\n        x: points[1][0],\n        y: points[1][1]\n      };\n    case 3:\n      return convertQToCInstruction({\n        type: \"Q\",\n        cpx: points[1][0],\n        cpy: points[1][1],\n        x: points[2][0],\n        y: points[2][1]\n      }, {\n        x: points[0][0],\n        y: points[0][1]\n      });\n    case 4:\n      return {\n        type: \"C\",\n        cp1x: points[1][0],\n        cp1y: points[1][1],\n        cp2x: points[2][0],\n        cp2y: points[2][1],\n        x: points[3][0],\n        y: points[3][1]\n      };\n    default:\n      throw new Error(\"Expected 2, 3 or 4 points for a line segment, got \" + points.length);\n  }\n}\nfunction warpInterpolate(path, threshold, deltaFunction) {\n  let prexX = 0;\n  let prexY = 0;\n  return path.map((segment) => {\n    const points = [[prexX, prexY]];\n    if (segment.type !== \"Z\") {\n      prexX = segment.x;\n      prexY = segment.y;\n    }\n    if (segment.type === \"C\") {\n      points.push([segment.cp1x, segment.cp1y]);\n      points.push([segment.cp2x, segment.cp2y]);\n      points.push([segment.x, segment.y]);\n    }\n    if (segment.type === \"L\") {\n      points.push([segment.x, segment.y]);\n    }\n    if (segment.type === \"C\" || segment.type === \"L\") {\n      return interpolateUntil(points, threshold, deltaFunction).map((rawSegment) => createLineSegment(rawSegment));\n    }\n    return [segment];\n  }).flat(1);\n}\nfunction svgPathInterpolate(path, threshold) {\n  let didWork = false;\n  const deltaFunction = (points) => {\n    const linearPoints = [\n      points[0].slice(0, 2),\n      points[points.length - 1].slice(0, 2)\n    ];\n    const delta = euclideanDistance(linearPoints);\n    didWork = didWork || delta > threshold;\n    return delta;\n  };\n  return warpInterpolate(path, threshold, deltaFunction);\n}\nvar warpTransform = (path, transformer) => {\n  return path.map((segment) => {\n    if (segment.type === \"L\") {\n      const { x, y } = transformer({ x: segment.x, y: segment.y });\n      return [\n        {\n          type: \"L\",\n          x,\n          y\n        }\n      ];\n    }\n    if (segment.type === \"C\") {\n      const { x, y } = transformer({ x: segment.x, y: segment.y });\n      const { x: cp1x, y: cp1y } = transformer({\n        x: segment.cp1x,\n        y: segment.cp1y\n      });\n      const { x: cp2x, y: cp2y } = transformer({\n        x: segment.cp2x,\n        y: segment.cp2y\n      });\n      return [\n        {\n          type: \"C\",\n          x,\n          y,\n          cp1x,\n          cp1y,\n          cp2x,\n          cp2y\n        }\n      ];\n    }\n    if (segment.type === \"M\") {\n      const { x, y } = transformer({ x: segment.x, y: segment.y });\n      return [\n        {\n          type: \"M\",\n          x,\n          y\n        }\n      ];\n    }\n    return [segment];\n  }).flat(1);\n};\nvar fixZInstruction = (instructions) => {\n  let prevX = 0;\n  let prevY = 0;\n  return instructions.map((instruction) => {\n    if (instruction.type === \"Z\") {\n      return [\n        {\n          type: \"L\",\n          x: prevX,\n          y: prevY\n        },\n        {\n          type: \"Z\"\n        }\n      ];\n    }\n    if (instruction.type === \"M\") {\n      prevX = instruction.x;\n      prevY = instruction.y;\n    }\n    return [instruction];\n  }).flat(1);\n};\n\n// src/warp-path/index.ts\nvar getDefaultInterpolationThreshold = (instructions) => {\n  const boundingBox = getBoundingBoxFromInstructions(instructions);\n  const longer = Math.max(boundingBox.y2 - boundingBox.y1, boundingBox.x2 - boundingBox.x1);\n  return longer * 0.01;\n};\nvar warpPath = (path, transformer, options) => {\n  const reduced = reduceInstructions(parsePath(path));\n  const withZFix = fixZInstruction(reduced);\n  const interpolated = svgPathInterpolate(withZFix, options?.interpolationThreshold ?? getDefaultInterpolationThreshold(withZFix));\n  return serializeInstructions(warpTransform(interpolated, transformer));\n};\n\n// src/index.ts\nvar PathInternals = {\n  getBoundingBoxFromInstructions,\n  debugPath,\n  cutPath\n};\nexport {\n  warpPath,\n  translatePath,\n  serializeInstructions,\n  scalePath,\n  reversePath,\n  resetPath,\n  reduceInstructions,\n  parsePath,\n  normalizePath,\n  interpolatePath,\n  getTangentAtLength,\n  getSubpaths,\n  getPointAtLength,\n  getLength,\n  getInstructionIndexAtLength,\n  getBoundingBox,\n  extendViewBox,\n  evolvePath,\n  cutPath,\n  PathInternals\n};\n", "// src/utils/make-circle.ts\nimport { serializeInstructions } from \"@remotion/paths\";\nvar makeCircle = ({ radius }) => {\n  const instructions = [\n    {\n      type: \"M\",\n      x: radius,\n      y: 0\n    },\n    {\n      type: \"a\",\n      rx: radius,\n      ry: radius,\n      xAxisRotation: 0,\n      largeArcFlag: true,\n      sweepFlag: true,\n      dx: 0,\n      dy: radius * 2\n    },\n    {\n      type: \"a\",\n      rx: radius,\n      ry: radius,\n      xAxisRotation: 0,\n      largeArcFlag: true,\n      sweepFlag: true,\n      dx: 0,\n      dy: -radius * 2\n    },\n    {\n      type: \"Z\"\n    }\n  ];\n  const path = serializeInstructions(instructions);\n  return {\n    height: radius * 2,\n    width: radius * 2,\n    path,\n    instructions,\n    transformOrigin: `${radius} ${radius}`\n  };\n};\n\n// src/components/render-svg.tsx\nimport React, { useMemo } from \"react\";\nimport { version } from \"react-dom\";\n\n// src/utils/does-react-support-canary.ts\nvar doesReactSupportTransformOriginProperty = (version) => {\n  if (version.includes(\"canary\") || version.includes(\"experimental\")) {\n    const last8Chars = parseInt(version.slice(-8), 10);\n    return last8Chars > 20230209;\n  }\n  const [major] = version.split(\".\").map(Number);\n  return major > 18;\n};\n\n// src/components/render-svg.tsx\nimport { jsx, jsxs } from \"react/jsx-runtime\";\nvar RenderSvg = ({\n  width,\n  height,\n  path,\n  style,\n  pathStyle,\n  transformOrigin,\n  debug,\n  instructions,\n  ...props\n}) => {\n  const actualStyle = useMemo(() => {\n    return {\n      overflow: \"visible\",\n      ...style ?? {}\n    };\n  }, [style]);\n  const actualPathStyle = useMemo(() => {\n    return {\n      transformBox: \"fill-box\",\n      ...pathStyle ?? {}\n    };\n  }, [pathStyle]);\n  const reactSupportsTransformOrigin = doesReactSupportTransformOriginProperty(version);\n  return /* @__PURE__ */ jsxs(\"svg\", {\n    width,\n    height,\n    viewBox: `0 0 ${width} ${height}`,\n    xmlns: \"http://www.w3.org/2000/svg\",\n    style: actualStyle,\n    children: [\n      /* @__PURE__ */ jsx(\"path\", {\n        ...reactSupportsTransformOrigin ? {\n          transformOrigin\n        } : {\n          \"transform-origin\": transformOrigin\n        },\n        d: path,\n        style: actualPathStyle,\n        ...props\n      }),\n      debug ? instructions.map((i, index) => {\n        if (i.type === \"C\") {\n          const prevInstruction = index === 0 ? instructions[instructions.length - 1] : instructions[index - 1];\n          if (prevInstruction.type === \"V\" || prevInstruction.type === \"H\" || prevInstruction.type === \"a\" || prevInstruction.type === \"Z\" || prevInstruction.type === \"t\" || prevInstruction.type === \"q\" || prevInstruction.type === \"l\" || prevInstruction.type === \"c\" || prevInstruction.type === \"m\" || prevInstruction.type === \"h\" || prevInstruction.type === \"s\" || prevInstruction.type === \"v\") {\n            return null;\n          }\n          const prevX = prevInstruction.x;\n          const prevY = prevInstruction.y;\n          return /* @__PURE__ */ jsxs(React.Fragment, {\n            children: [\n              /* @__PURE__ */ jsx(\"path\", {\n                d: `M ${prevX} ${prevY} ${i.cp1x} ${i.cp1y}`,\n                strokeWidth: 2,\n                stroke: \"rgba(0, 0, 0, 0.4)\"\n              }),\n              /* @__PURE__ */ jsx(\"path\", {\n                d: `M ${i.x} ${i.y} ${i.cp2x} ${i.cp2y}`,\n                strokeWidth: 2,\n                stroke: \"rgba(0, 0, 0, 0.4)\"\n              }),\n              /* @__PURE__ */ jsx(\"circle\", {\n                cx: i.cp1x,\n                cy: i.cp1y,\n                r: 3,\n                fill: \"white\",\n                strokeWidth: 2,\n                stroke: \"black\"\n              }),\n              /* @__PURE__ */ jsx(\"circle\", {\n                cx: i.cp2x,\n                cy: i.cp2y,\n                r: 3,\n                strokeWidth: 2,\n                fill: \"white\",\n                stroke: \"black\"\n              })\n            ]\n          }, index);\n        }\n        return null;\n      }) : null\n    ]\n  });\n};\n\n// src/components/circle.tsx\nimport { jsx as jsx2 } from \"react/jsx-runtime\";\nvar Circle = ({ radius, ...props }) => {\n  return /* @__PURE__ */ jsx2(RenderSvg, {\n    ...makeCircle({ radius }),\n    ...props\n  });\n};\n// src/utils/make-ellipse.ts\nimport { serializeInstructions as serializeInstructions2 } from \"@remotion/paths\";\nvar makeEllipse = ({ rx, ry }) => {\n  const instructions = [\n    {\n      type: \"M\",\n      x: rx,\n      y: 0\n    },\n    {\n      type: \"a\",\n      rx,\n      ry,\n      xAxisRotation: 0,\n      largeArcFlag: true,\n      sweepFlag: false,\n      dx: 1,\n      dy: 0\n    },\n    {\n      type: \"Z\"\n    }\n  ];\n  const path = serializeInstructions2(instructions);\n  return {\n    width: rx * 2,\n    height: ry * 2,\n    path,\n    instructions,\n    transformOrigin: `${rx} ${ry}`\n  };\n};\n\n// src/components/ellipse.tsx\nimport { jsx as jsx3 } from \"react/jsx-runtime\";\nvar Ellipse = ({ rx, ry, ...props }) => {\n  return /* @__PURE__ */ jsx3(RenderSvg, {\n    ...makeEllipse({ rx, ry }),\n    ...props\n  });\n};\n// src/utils/make-heart.ts\nimport { serializeInstructions as serializeInstructions3 } from \"@remotion/paths\";\nvar makeHeart = ({\n  height,\n  aspectRatio = 1.1,\n  bottomRoundnessAdjustment = 0,\n  depthAdjustment = 0\n}) => {\n  const width = height * aspectRatio;\n  const bottomControlPointX = 23 / 110 * width + bottomRoundnessAdjustment * width;\n  const bottomControlPointY = 69 / 100 * height;\n  const bottomLeftControlPointY = 60 / 100 * height;\n  const topLeftControlPoint = 13 / 100 * height;\n  const topBezierWidth = 29 / 110 * width;\n  const topRightControlPointX = 15 / 110 * width;\n  const innerControlPointX = 5 / 110 * width;\n  const innerControlPointY = 7 / 100 * height;\n  const depth = 17 / 100 * height + depthAdjustment * height;\n  const instructions = [\n    {\n      type: \"M\",\n      x: width / 2,\n      y: height\n    },\n    {\n      type: \"C\",\n      cp1x: width / 2 - bottomControlPointX,\n      cp1y: bottomControlPointY,\n      cp2x: 0,\n      cp2y: bottomLeftControlPointY,\n      x: 0,\n      y: height / 4\n    },\n    {\n      type: \"C\",\n      cp1x: 0,\n      cp1y: topLeftControlPoint,\n      cp2x: width / 4 - topBezierWidth / 2,\n      cp2y: 0,\n      x: width / 4,\n      y: 0\n    },\n    {\n      type: \"C\",\n      cp1x: width / 4 + topBezierWidth / 2,\n      cp1y: 0,\n      cp2x: width / 2 - innerControlPointX,\n      cp2y: innerControlPointY,\n      x: width / 2,\n      y: depth\n    },\n    {\n      type: \"C\",\n      cp1x: width / 2 + innerControlPointX,\n      cp1y: innerControlPointY,\n      cp2x: width / 2 + topRightControlPointX,\n      cp2y: 0,\n      x: width / 4 * 3,\n      y: 0\n    },\n    {\n      type: \"C\",\n      cp1x: width / 4 * 3 + topBezierWidth / 2,\n      cp1y: 0,\n      cp2x: width,\n      cp2y: topLeftControlPoint,\n      x: width,\n      y: height / 4\n    },\n    {\n      type: \"C\",\n      x: width / 2,\n      y: height,\n      cp1x: width,\n      cp1y: bottomLeftControlPointY,\n      cp2x: width / 2 + bottomControlPointX,\n      cp2y: bottomControlPointY\n    },\n    {\n      type: \"Z\"\n    }\n  ];\n  const path = serializeInstructions3(instructions);\n  return {\n    path,\n    width,\n    height,\n    transformOrigin: `${width / 2} ${height / 2}`,\n    instructions\n  };\n};\n\n// src/components/heart.tsx\nimport { jsx as jsx4 } from \"react/jsx-runtime\";\nvar Heart = ({\n  aspectRatio,\n  height,\n  bottomRoundnessAdjustment = 0,\n  depthAdjustment = 0,\n  ...props\n}) => {\n  return /* @__PURE__ */ jsx4(RenderSvg, {\n    ...makeHeart({\n      aspectRatio,\n      height,\n      bottomRoundnessAdjustment,\n      depthAdjustment\n    }),\n    ...props\n  });\n};\n// src/utils/make-pie.ts\nimport { serializeInstructions as serializeInstructions4 } from \"@remotion/paths\";\nvar getCoord = ({\n  counterClockwise,\n  actualProgress,\n  rotation,\n  radius,\n  coord\n}) => {\n  const factor = counterClockwise ? -1 : 1;\n  const val = Math[coord === \"x\" ? \"cos\" : \"sin\"](factor * actualProgress * Math.PI * 2 + Math.PI * 1.5 + rotation) * radius + radius;\n  const rounded = Math.round(val * 1e5) / 1e5;\n  return rounded;\n};\nvar makePie = ({\n  progress,\n  radius,\n  closePath = true,\n  counterClockwise = false,\n  rotation = 0\n}) => {\n  const actualProgress = Math.min(Math.max(progress, 0), 1);\n  const endAngleX = getCoord({\n    actualProgress,\n    coord: \"x\",\n    counterClockwise,\n    radius,\n    rotation\n  });\n  const endAngleY = getCoord({\n    actualProgress,\n    coord: \"y\",\n    counterClockwise,\n    radius,\n    rotation\n  });\n  const start = {\n    x: getCoord({\n      actualProgress: 0,\n      coord: \"x\",\n      counterClockwise,\n      radius,\n      rotation\n    }),\n    y: getCoord({\n      actualProgress: 0,\n      coord: \"y\",\n      counterClockwise,\n      radius,\n      rotation\n    })\n  };\n  const end = { x: endAngleX, y: endAngleY };\n  const instructions = [\n    {\n      type: \"M\",\n      ...start\n    },\n    {\n      type: \"A\",\n      rx: radius,\n      ry: radius,\n      xAxisRotation: 0,\n      largeArcFlag: false,\n      sweepFlag: !counterClockwise,\n      x: actualProgress <= 0.5 ? endAngleX : getCoord({\n        actualProgress: 0.5,\n        coord: \"x\",\n        counterClockwise,\n        radius,\n        rotation\n      }),\n      y: actualProgress <= 0.5 ? endAngleY : getCoord({\n        actualProgress: 0.5,\n        coord: \"y\",\n        counterClockwise,\n        radius,\n        rotation\n      })\n    },\n    actualProgress > 0.5 ? {\n      type: \"A\",\n      rx: radius,\n      ry: radius,\n      xAxisRotation: 0,\n      largeArcFlag: false,\n      sweepFlag: !counterClockwise,\n      ...end\n    } : null,\n    actualProgress > 0 && actualProgress < 1 && closePath ? {\n      type: \"L\",\n      x: radius,\n      y: radius\n    } : null,\n    closePath ? {\n      type: \"Z\"\n    } : null\n  ].filter(Boolean);\n  const path = serializeInstructions4(instructions);\n  return {\n    height: radius * 2,\n    width: radius * 2,\n    path,\n    instructions,\n    transformOrigin: `${radius} ${radius}`\n  };\n};\n\n// src/components/pie.tsx\nimport { jsx as jsx5 } from \"react/jsx-runtime\";\nvar Pie = ({\n  radius,\n  progress,\n  closePath,\n  counterClockwise,\n  rotation,\n  ...props\n}) => {\n  return /* @__PURE__ */ jsx5(RenderSvg, {\n    ...makePie({ radius, progress, closePath, counterClockwise, rotation }),\n    ...props\n  });\n};\n// src/utils/make-polygon.ts\nimport {\n  PathInternals,\n  reduceInstructions,\n  resetPath,\n  serializeInstructions as serializeInstructions5\n} from \"@remotion/paths\";\n\n// src/utils/join-points.ts\nvar shortenVector = (vector, radius) => {\n  const [x, y] = vector;\n  const currentLength = Math.sqrt(x * x + y * y);\n  const scalingFactor = (currentLength - radius) / currentLength;\n  return [x * scalingFactor, y * scalingFactor];\n};\nvar scaleVectorToLength = (vector, length) => {\n  const [x, y] = vector;\n  const currentLength = Math.sqrt(x * x + y * y);\n  const scalingFactor = length / currentLength;\n  return [x * scalingFactor, y * scalingFactor];\n};\nvar joinPoints = (points, {\n  edgeRoundness,\n  cornerRadius,\n  roundCornerStrategy\n}) => {\n  return points.map(([x, y], i) => {\n    const prevPointIndex = i === 0 ? points.length - 2 : i - 1;\n    const prevPoint = points[prevPointIndex];\n    const nextPointIndex = i === points.length - 1 ? 1 : i + 1;\n    const nextPoint = points[nextPointIndex];\n    const middleOfLine = [(x + nextPoint[0]) / 2, (y + nextPoint[1]) / 2];\n    const prevPointMiddleOfLine = [\n      (x + prevPoint[0]) / 2,\n      (y + prevPoint[1]) / 2\n    ];\n    const prevVector = [x - prevPoint[0], y - prevPoint[1]];\n    const nextVector = [nextPoint[0] - x, nextPoint[1] - y];\n    if (i === 0) {\n      if (edgeRoundness !== null) {\n        return [\n          {\n            type: \"M\",\n            x: middleOfLine[0],\n            y: middleOfLine[1]\n          }\n        ];\n      }\n      if (cornerRadius !== 0) {\n        const computeRadius = shortenVector(nextVector, cornerRadius);\n        return [\n          {\n            type: \"M\",\n            x: computeRadius[0] + x,\n            y: computeRadius[1] + y\n          }\n        ];\n      }\n      return [\n        {\n          type: \"M\",\n          x,\n          y\n        }\n      ];\n    }\n    if (cornerRadius && edgeRoundness !== null) {\n      throw new Error(`\"cornerRadius\" and \"edgeRoundness\" cannot be specified at the same time.`);\n    }\n    if (edgeRoundness === null) {\n      if (cornerRadius === 0) {\n        return [\n          {\n            type: \"L\",\n            x,\n            y\n          }\n        ];\n      }\n      const prevVectorMinusRadius = shortenVector(prevVector, cornerRadius);\n      const prevVectorLength = scaleVectorToLength(prevVector, cornerRadius);\n      const nextVectorMinusRadius = scaleVectorToLength(nextVector, cornerRadius);\n      const firstDraw = [\n        prevPoint[0] + prevVectorMinusRadius[0],\n        prevPoint[1] + prevVectorMinusRadius[1]\n      ];\n      return [\n        {\n          type: \"L\",\n          x: firstDraw[0],\n          y: firstDraw[1]\n        },\n        roundCornerStrategy === \"arc\" ? {\n          type: \"a\",\n          rx: cornerRadius,\n          ry: cornerRadius,\n          xAxisRotation: 0,\n          dx: prevVectorLength[0] + nextVectorMinusRadius[0],\n          dy: prevVectorLength[1] + nextVectorMinusRadius[1],\n          largeArcFlag: false,\n          sweepFlag: true\n        } : {\n          type: \"C\",\n          x: firstDraw[0] + prevVectorLength[0] + nextVectorMinusRadius[0],\n          y: firstDraw[1] + prevVectorLength[1] + nextVectorMinusRadius[1],\n          cp1x: x,\n          cp1y: y,\n          cp2x: x,\n          cp2y: y\n        }\n      ];\n    }\n    const controlPoint1 = [\n      prevPointMiddleOfLine[0] + prevVector[0] * edgeRoundness * 0.5,\n      prevPointMiddleOfLine[1] + prevVector[1] * edgeRoundness * 0.5\n    ];\n    const controlPoint2 = [\n      middleOfLine[0] - nextVector[0] * edgeRoundness * 0.5,\n      middleOfLine[1] - nextVector[1] * edgeRoundness * 0.5\n    ];\n    return [\n      {\n        type: \"C\",\n        cp1x: controlPoint1[0],\n        cp1y: controlPoint1[1],\n        cp2x: controlPoint2[0],\n        cp2y: controlPoint2[1],\n        x: middleOfLine[0],\n        y: middleOfLine[1]\n      }\n    ];\n  }).flat(1);\n};\n\n// src/utils/make-polygon.ts\nfunction polygon({\n  points,\n  radius,\n  centerX,\n  centerY,\n  cornerRadius,\n  edgeRoundness\n}) {\n  const degreeIncrement = Math.PI * 2 / points;\n  const d = new Array(points).fill(0).map((_, i) => {\n    const angle = degreeIncrement * i - Math.PI / 2;\n    const point = {\n      x: centerX + radius * Math.cos(angle),\n      y: centerY + radius * Math.sin(angle)\n    };\n    return [point.x, point.y];\n  });\n  return joinPoints([...d, d[0]], {\n    edgeRoundness,\n    cornerRadius,\n    roundCornerStrategy: cornerRadius > 0 ? \"bezier\" : \"arc\"\n  });\n}\nvar makePolygon = ({\n  points,\n  radius,\n  cornerRadius = 0,\n  edgeRoundness = null\n}) => {\n  if (points < 3) {\n    throw new Error(`\"points\" should be minimum 3, got ${points}`);\n  }\n  const width = 2 * radius;\n  const height = 2 * radius;\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const polygonPathInstructions = polygon({\n    points,\n    radius,\n    centerX,\n    centerY,\n    cornerRadius,\n    edgeRoundness\n  });\n  const reduced = reduceInstructions(polygonPathInstructions);\n  const path = resetPath(serializeInstructions5(reduced));\n  const boundingBox = PathInternals.getBoundingBoxFromInstructions(reduced);\n  return {\n    path,\n    width: boundingBox.width,\n    height: boundingBox.height,\n    transformOrigin: `${centerX} ${centerY}`,\n    instructions: polygonPathInstructions\n  };\n};\n\n// src/components/polygon.tsx\nimport { jsx as jsx6 } from \"react/jsx-runtime\";\nvar Polygon = ({\n  points,\n  radius,\n  cornerRadius,\n  edgeRoundness,\n  ...props\n}) => {\n  return /* @__PURE__ */ jsx6(RenderSvg, {\n    ...makePolygon({\n      points,\n      cornerRadius,\n      edgeRoundness,\n      radius\n    }),\n    ...props\n  });\n};\n// src/utils/make-rect.ts\nimport { serializeInstructions as serializeInstructions6 } from \"@remotion/paths\";\nvar makeRect = ({\n  width,\n  height,\n  edgeRoundness = null,\n  cornerRadius = 0\n}) => {\n  const transformOrigin = [width / 2, height / 2];\n  const instructions = [\n    ...joinPoints([\n      [cornerRadius, 0],\n      [width, 0],\n      [width, height],\n      [0, height],\n      [0, 0]\n    ], { edgeRoundness, cornerRadius, roundCornerStrategy: \"arc\" }),\n    {\n      type: \"Z\"\n    }\n  ];\n  const path = serializeInstructions6(instructions);\n  return {\n    width,\n    height,\n    instructions,\n    path,\n    transformOrigin: transformOrigin.join(\" \")\n  };\n};\n\n// src/components/rect.tsx\nimport { jsx as jsx7 } from \"react/jsx-runtime\";\nvar Rect = ({\n  width,\n  edgeRoundness,\n  height,\n  cornerRadius,\n  ...props\n}) => {\n  return /* @__PURE__ */ jsx7(RenderSvg, {\n    ...makeRect({ height, width, edgeRoundness, cornerRadius }),\n    ...props\n  });\n};\n// src/utils/make-star.ts\nimport {\n  PathInternals as PathInternals2,\n  reduceInstructions as reduceInstructions2,\n  resetPath as resetPath2,\n  serializeInstructions as serializeInstructions7\n} from \"@remotion/paths\";\nvar star = ({\n  centerX,\n  centerY,\n  points,\n  innerRadius,\n  outerRadius,\n  cornerRadius,\n  edgeRoundness\n}) => {\n  const degreeIncrement = Math.PI * 2 / (points * 2);\n  const d = new Array(points * 2).fill(true).map((_p, i) => {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = degreeIncrement * i - Math.PI / 2;\n    const point = {\n      x: centerX + radius * Math.cos(angle),\n      y: centerY + radius * Math.sin(angle)\n    };\n    return [point.x, point.y];\n  });\n  return [\n    ...joinPoints([...d, d[0]], {\n      edgeRoundness,\n      cornerRadius,\n      roundCornerStrategy: cornerRadius > 0 ? \"bezier\" : \"arc\"\n    }),\n    { type: \"Z\" }\n  ];\n};\nvar makeStar = ({\n  points,\n  innerRadius,\n  outerRadius,\n  cornerRadius = 0,\n  edgeRoundness = null\n}) => {\n  const width = outerRadius * 2;\n  const height = outerRadius * 2;\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const starPathInstructions = star({\n    centerX,\n    centerY,\n    points,\n    innerRadius,\n    outerRadius,\n    cornerRadius,\n    edgeRoundness\n  });\n  const reduced = reduceInstructions2(starPathInstructions);\n  const path = resetPath2(serializeInstructions7(reduced));\n  const boundingBox = PathInternals2.getBoundingBoxFromInstructions(reduced);\n  return {\n    path,\n    width: boundingBox.width,\n    height: boundingBox.height,\n    transformOrigin: `${centerX} ${centerY}`,\n    instructions: starPathInstructions\n  };\n};\n\n// src/components/star.tsx\nimport { jsx as jsx8 } from \"react/jsx-runtime\";\nvar Star = ({\n  innerRadius,\n  outerRadius,\n  points,\n  cornerRadius,\n  edgeRoundness,\n  ...props\n}) => {\n  return /* @__PURE__ */ jsx8(RenderSvg, {\n    ...makeStar({\n      innerRadius,\n      outerRadius,\n      points,\n      cornerRadius,\n      edgeRoundness\n    }),\n    ...props\n  });\n};\n// src/utils/make-triangle.ts\nimport { serializeInstructions as serializeInstructions8 } from \"@remotion/paths\";\nvar makeTriangle = ({\n  length,\n  direction = \"right\",\n  edgeRoundness = null,\n  cornerRadius = 0\n}) => {\n  if (typeof length !== \"number\") {\n    throw new Error(`\"length\" of a triangle must be a number, got ${JSON.stringify(length)}`);\n  }\n  const longerDimension = length;\n  const shorterSize = Math.sqrt(length ** 2 * 0.75);\n  const points = {\n    up: [\n      [longerDimension / 2, 0],\n      [0, shorterSize],\n      [longerDimension, shorterSize],\n      [longerDimension / 2, 0]\n    ],\n    right: [\n      [0, 0],\n      [0, longerDimension],\n      [shorterSize, longerDimension / 2],\n      [0, 0]\n    ],\n    down: [\n      [0, 0],\n      [longerDimension, 0],\n      [longerDimension / 2, shorterSize],\n      [0, 0]\n    ],\n    left: [\n      [shorterSize, 0],\n      [shorterSize, longerDimension],\n      [0, longerDimension / 2],\n      [shorterSize, 0]\n    ]\n  };\n  const transformOriginX = {\n    left: shorterSize / 3 * 2,\n    right: shorterSize / 3,\n    up: longerDimension / 2,\n    down: longerDimension / 2\n  }[direction];\n  const transformOriginY = {\n    up: shorterSize / 3 * 2,\n    down: shorterSize / 3,\n    left: longerDimension / 2,\n    right: longerDimension / 2\n  }[direction];\n  const instructions = [\n    ...joinPoints(points[direction], {\n      edgeRoundness,\n      cornerRadius,\n      roundCornerStrategy: \"bezier\"\n    }),\n    {\n      type: \"Z\"\n    }\n  ];\n  const path = serializeInstructions8(instructions);\n  return {\n    path,\n    instructions,\n    width: direction === \"up\" || direction === \"down\" ? length : shorterSize,\n    height: direction === \"up\" || direction === \"down\" ? shorterSize : length,\n    transformOrigin: `${transformOriginX} ${transformOriginY}`\n  };\n};\n\n// src/components/triangle.tsx\nimport { jsx as jsx9 } from \"react/jsx-runtime\";\nvar Triangle = ({\n  length,\n  direction,\n  edgeRoundness,\n  cornerRadius,\n  ...props\n}) => {\n  return /* @__PURE__ */ jsx9(RenderSvg, {\n    ...makeTriangle({ length, direction, edgeRoundness, cornerRadius }),\n    ...props\n  });\n};\nexport {\n  makeTriangle,\n  makeStar,\n  makeRect,\n  makePolygon,\n  makePie,\n  makeHeart,\n  makeEllipse,\n  makeCircle,\n  Triangle,\n  Star,\n  Rect,\n  Polygon,\n  Pie,\n  Heart,\n  Ellipse,\n  Circle\n};\n"],
  "mappings": "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",
  "names": ["import_jsx_runtime", "import_jsx_runtime", "import_jsx_runtime", "import_jsx_runtime", "import_jsx_runtime", "import_jsx_runtime", "import_jsx_runtime", "import_jsx_runtime"]
}
