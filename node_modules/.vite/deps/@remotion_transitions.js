import {
  NoReactInternals
} from "./chunk-GRI3NTIY.js";
import {
  AbsoluteFill,
  Internals,
  Sequence,
  interpolate,
  measureSpring,
  spring,
  useCurrentFrame,
  useVideoConfig
} from "./chunk-KLLAORJI.js";
import "./chunk-NXESFFTV.js";
import {
  require_jsx_runtime
} from "./chunk-6PXSGDAH.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@remotion/transitions/dist/esm/index.mjs
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
var epsilon = 0.01;
var SlidePresentation = ({
  children,
  presentationProgress,
  presentationDirection,
  passedProps: { direction = "from-left", enterStyle, exitStyle }
}) => {
  const directionStyle = (0, import_react.useMemo)(() => {
    const presentationProgressWithEpsilonCorrection = presentationProgress === 1 ? presentationProgress * 100 : presentationProgress * 100 - epsilon;
    if (presentationDirection === "exiting") {
      switch (direction) {
        case "from-left":
          return {
            transform: `translateX(${presentationProgressWithEpsilonCorrection}%)`
          };
        case "from-right":
          return {
            transform: `translateX(${-presentationProgress * 100}%)`
          };
        case "from-top":
          return {
            transform: `translateY(${presentationProgressWithEpsilonCorrection}%)`
          };
        case "from-bottom":
          return {
            transform: `translateY(${-presentationProgress * 100}%)`
          };
        default:
          throw new Error(`Invalid direction: ${direction}`);
      }
    }
    switch (direction) {
      case "from-left":
        return {
          transform: `translateX(${-100 + presentationProgress * 100}%)`
        };
      case "from-right":
        return {
          transform: `translateX(${100 - presentationProgressWithEpsilonCorrection}%)`
        };
      case "from-top":
        return {
          transform: `translateY(${-100 + presentationProgress * 100}%)`
        };
      case "from-bottom":
        return {
          transform: `translateY(${100 - presentationProgressWithEpsilonCorrection}%)`
        };
      default:
        throw new Error(`Invalid direction: ${direction}`);
    }
  }, [presentationDirection, presentationProgress, direction]);
  const style = (0, import_react.useMemo)(() => {
    return {
      width: "100%",
      height: "100%",
      justifyContent: "center",
      alignItems: "center",
      ...directionStyle,
      ...presentationDirection === "entering" ? enterStyle : exitStyle
    };
  }, [directionStyle, enterStyle, exitStyle, presentationDirection]);
  return (0, import_jsx_runtime.jsx)(AbsoluteFill, {
    style,
    children
  });
};
var slide = (props) => {
  return {
    component: SlidePresentation,
    props: props ?? {}
  };
};
var linearTiming = (options) => {
  return {
    getDurationInFrames: () => {
      return options.durationInFrames;
    },
    getProgress: ({ frame }) => {
      return interpolate(frame, [0, options.durationInFrames], [0, 1], {
        easing: options.easing,
        extrapolateLeft: "clamp",
        extrapolateRight: "clamp"
      });
    }
  };
};
var springTiming = (options = {}) => {
  return {
    getDurationInFrames: ({ fps }) => {
      if (options.durationInFrames) {
        return options.durationInFrames;
      }
      return measureSpring({
        config: options.config,
        threshold: options.durationRestThreshold,
        fps
      });
    },
    getProgress: ({ fps, frame }) => {
      const to = options.reverse ? 0 : 1;
      const from = options.reverse ? 1 : 0;
      return spring({
        fps,
        frame,
        to,
        from,
        config: options.config,
        durationInFrames: options.durationInFrames,
        durationRestThreshold: options.durationRestThreshold,
        reverse: options.reverse
      });
    }
  };
};
var EnteringContext = import_react3.default.createContext(null);
var ExitingContext = import_react3.default.createContext(null);
var WrapInEnteringProgressContext = ({ presentationProgress, children }) => {
  const value = (0, import_react3.useMemo)(() => {
    return {
      enteringProgress: presentationProgress
    };
  }, [presentationProgress]);
  return (0, import_jsx_runtime2.jsx)(EnteringContext.Provider, {
    value,
    children
  });
};
var WrapInExitingProgressContext = ({ presentationProgress, children }) => {
  const value = (0, import_react3.useMemo)(() => {
    return {
      exitingProgress: presentationProgress
    };
  }, [presentationProgress]);
  return (0, import_jsx_runtime2.jsx)(ExitingContext.Provider, {
    value,
    children
  });
};
var flattenChildren = (children) => {
  const childrenArray = import_react4.default.Children.toArray(children);
  return childrenArray.reduce((flatChildren, child) => {
    if (child.type === import_react4.default.Fragment) {
      return flatChildren.concat(flattenChildren(child.props.children));
    }
    flatChildren.push(child);
    return flatChildren;
  }, []);
};
var validateDurationInFrames = NoReactInternals.validateDurationInFrames;
var TransitionSeriesTransition = function(_props) {
  return null;
};
var SeriesSequence = ({ children }) => {
  return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, {
    children
  });
};
var TransitionSeriesChildren = ({
  children
}) => {
  const { fps } = useVideoConfig();
  const frame = useCurrentFrame();
  const childrenValue = (0, import_react2.useMemo)(() => {
    let transitionOffsets = 0;
    let startFrame = 0;
    const flattedChildren = flattenChildren(children);
    return import_react2.Children.map(flattedChildren, (child, i) => {
      const current = child;
      if (typeof current === "string") {
        if (current.trim() === "") {
          return null;
        }
        throw new TypeError(`The <TransitionSeries /> component only accepts a list of <TransitionSeries.Sequence /> components as its children, but you passed a string "${current}"`);
      }
      const hasPrev = flattedChildren[i - 1];
      const nextPrev = flattedChildren[i + 1];
      const prev = typeof hasPrev === "string" || typeof hasPrev === "undefined" ? null : hasPrev.type === TransitionSeriesTransition ? hasPrev : null;
      const next = typeof nextPrev === "string" || typeof nextPrev === "undefined" ? null : nextPrev.type === TransitionSeriesTransition ? nextPrev : null;
      const prevIsTransition = typeof hasPrev === "string" || typeof hasPrev === "undefined" ? false : hasPrev.type === TransitionSeriesTransition;
      if (current.type === TransitionSeriesTransition) {
        if (prevIsTransition) {
          throw new TypeError(`A <TransitionSeries.Transition /> component must not be followed by another <TransitionSeries.Transition /> component (nth children = ${i - 1} and ${i})`);
        }
        return null;
      }
      if (current.type !== SeriesSequence) {
        throw new TypeError(`The <TransitionSeries /> component only accepts a list of <TransitionSeries.Sequence /> and <TransitionSeries.Transition /> components as its children, but got ${current} instead`);
      }
      const castedChildAgain = current;
      const debugInfo = `index = ${i}, duration = ${castedChildAgain.props.durationInFrames}`;
      if (!castedChildAgain?.props.children) {
        throw new TypeError(`A <TransitionSeries.Sequence /> component (${debugInfo}) was detected to not have any children. Delete it to fix this error.`);
      }
      const durationInFramesProp = castedChildAgain.props.durationInFrames;
      const {
        durationInFrames,
        children: _children,
        ...passedProps
      } = castedChildAgain.props;
      validateDurationInFrames(durationInFramesProp, {
        component: `of a <TransitionSeries.Sequence /> component`,
        allowFloats: true
      });
      const offset = castedChildAgain.props.offset ?? 0;
      if (Number.isNaN(offset)) {
        throw new TypeError(`The "offset" property of a <TransitionSeries.Sequence /> must not be NaN, but got NaN (${debugInfo}).`);
      }
      if (!Number.isFinite(offset)) {
        throw new TypeError(`The "offset" property of a <TransitionSeries.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);
      }
      if (offset % 1 !== 0) {
        throw new TypeError(`The "offset" property of a <TransitionSeries.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);
      }
      const currentStartFrame = startFrame + offset;
      let duration = 0;
      if (prev) {
        duration = prev.props.timing.getDurationInFrames({
          fps
        });
        transitionOffsets -= duration;
      }
      let actualStartFrame = currentStartFrame + transitionOffsets;
      startFrame += durationInFramesProp + offset;
      if (actualStartFrame < 0) {
        startFrame -= actualStartFrame;
        actualStartFrame = 0;
      }
      const nextProgress = next ? next.props.timing.getProgress({
        frame: frame - actualStartFrame - durationInFrames + next.props.timing.getDurationInFrames({ fps }),
        fps
      }) : null;
      const prevProgress = prev ? prev.props.timing.getProgress({
        frame: frame - actualStartFrame,
        fps
      }) : null;
      if (next && durationInFramesProp < next.props.timing.getDurationInFrames({ fps })) {
        throw new Error(`The duration of a <TransitionSeries.Sequence /> must not be shorter than the duration of the next <TransitionSeries.Transition />. The transition is ${next.props.timing.getDurationInFrames({ fps })} frames long, but the sequence is only ${durationInFramesProp} frames long (${debugInfo})`);
      }
      if (prev && durationInFramesProp < prev.props.timing.getDurationInFrames({ fps })) {
        throw new Error(`The duration of a <TransitionSeries.Sequence /> must not be shorter than the duration of the previous <TransitionSeries.Transition />. The transition is ${prev.props.timing.getDurationInFrames({ fps })} frames long, but the sequence is only ${durationInFramesProp} frames long (${debugInfo})`);
      }
      if (next && prev && nextProgress !== null && prevProgress !== null) {
        const nextPresentation = next.props.presentation ?? slide();
        const prevPresentation = prev.props.presentation ?? slide();
        const UppercaseNextPresentation = nextPresentation.component;
        const UppercasePrevPresentation = prevPresentation.component;
        return (0, import_jsx_runtime3.jsx)(Sequence, {
          from: actualStartFrame,
          durationInFrames: durationInFramesProp,
          ...passedProps,
          name: passedProps.name || "<TS.Sequence>",
          children: (0, import_jsx_runtime3.jsx)(UppercaseNextPresentation, {
            passedProps: nextPresentation.props ?? {},
            presentationDirection: "exiting",
            presentationProgress: nextProgress,
            presentationDurationInFrames: next.props.timing.getDurationInFrames({ fps }),
            children: (0, import_jsx_runtime3.jsx)(WrapInExitingProgressContext, {
              presentationProgress: nextProgress,
              children: (0, import_jsx_runtime3.jsx)(UppercasePrevPresentation, {
                passedProps: prevPresentation.props ?? {},
                presentationDirection: "entering",
                presentationProgress: prevProgress,
                presentationDurationInFrames: prev.props.timing.getDurationInFrames({ fps }),
                children: (0, import_jsx_runtime3.jsx)(WrapInEnteringProgressContext, {
                  presentationProgress: prevProgress,
                  children: child
                })
              })
            })
          })
        }, i);
      }
      if (prevProgress !== null && prev) {
        const prevPresentation = prev.props.presentation ?? slide();
        const UppercasePrevPresentation = prevPresentation.component;
        return (0, import_jsx_runtime3.jsx)(Sequence, {
          from: actualStartFrame,
          durationInFrames: durationInFramesProp,
          ...passedProps,
          name: passedProps.name || "<TS.Sequence>",
          children: (0, import_jsx_runtime3.jsx)(UppercasePrevPresentation, {
            passedProps: prevPresentation.props ?? {},
            presentationDirection: "entering",
            presentationProgress: prevProgress,
            presentationDurationInFrames: prev.props.timing.getDurationInFrames({ fps }),
            children: (0, import_jsx_runtime3.jsx)(WrapInEnteringProgressContext, {
              presentationProgress: prevProgress,
              children: child
            })
          })
        }, i);
      }
      if (nextProgress !== null && next) {
        const nextPresentation = next.props.presentation ?? slide();
        const UppercaseNextPresentation = nextPresentation.component;
        return (0, import_jsx_runtime3.jsx)(Sequence, {
          from: actualStartFrame,
          durationInFrames: durationInFramesProp,
          ...passedProps,
          name: passedProps.name || "<TS.Sequence>",
          children: (0, import_jsx_runtime3.jsx)(UppercaseNextPresentation, {
            passedProps: nextPresentation.props ?? {},
            presentationDirection: "exiting",
            presentationProgress: nextProgress,
            presentationDurationInFrames: next.props.timing.getDurationInFrames({ fps }),
            children: (0, import_jsx_runtime3.jsx)(WrapInExitingProgressContext, {
              presentationProgress: nextProgress,
              children: child
            })
          })
        }, i);
      }
      return (0, import_jsx_runtime3.jsx)(Sequence, {
        from: actualStartFrame,
        durationInFrames: durationInFramesProp,
        ...passedProps,
        name: passedProps.name || "<TS.Sequence>",
        children: child
      }, i);
    });
  }, [children, fps, frame]);
  return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, {
    children: childrenValue
  });
};
var TransitionSeries = ({ children, name, layout: passedLayout, ...otherProps }) => {
  const displayName = name ?? "<TransitionSeries>";
  const layout = passedLayout ?? "absolute-fill";
  if (NoReactInternals.ENABLE_V5_BREAKING_CHANGES && layout !== "absolute-fill") {
    throw new TypeError(`The "layout" prop of <TransitionSeries /> is not supported anymore in v5. TransitionSeries' must be absolutely positioned.`);
  }
  return (0, import_jsx_runtime3.jsx)(Sequence, {
    name: displayName,
    layout,
    ...otherProps,
    children: (0, import_jsx_runtime3.jsx)(TransitionSeriesChildren, {
      children
    })
  });
};
TransitionSeries.Sequence = SeriesSequence;
TransitionSeries.Transition = TransitionSeriesTransition;
Internals.addSequenceStackTraces(TransitionSeries);
Internals.addSequenceStackTraces(SeriesSequence);
var useTransitionProgress = () => {
  const entering = import_react5.default.useContext(EnteringContext);
  const exiting = import_react5.default.useContext(ExitingContext);
  if (!entering && !exiting) {
    return {
      isInTransitionSeries: false,
      entering: 1,
      exiting: 0
    };
  }
  return {
    isInTransitionSeries: true,
    entering: entering?.enteringProgress ?? 1,
    exiting: exiting?.exitingProgress ?? 0
  };
};
export {
  TransitionSeries,
  linearTiming,
  springTiming,
  useTransitionProgress
};
//# sourceMappingURL=@remotion_transitions.js.map
