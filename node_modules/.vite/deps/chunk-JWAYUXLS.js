import {
  require_react_dom
} from "./chunk-NXESFFTV.js";
import {
  require_jsx_runtime
} from "./chunk-6PXSGDAH.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@remotion/paths/dist/esm/index.mjs
var length = {
  a: 7,
  A: 7,
  C: 6,
  c: 6,
  H: 1,
  h: 1,
  L: 2,
  l: 2,
  M: 2,
  m: 2,
  Q: 4,
  q: 4,
  S: 4,
  s: 4,
  T: 2,
  t: 2,
  V: 1,
  v: 1,
  Z: 0,
  z: 0
};
var chunkExact = (array, instruction) => {
  const chunks = [];
  const expectedSize = length[instruction];
  if (array.length % expectedSize !== 0) {
    throw new Error(`Expected number of arguments of SVG instruction "${instruction} ${array.join(" ")}" to be a multiple of ${expectedSize}`);
  }
  for (let i = 0; i < array.length; i += expectedSize) {
    chunks.push(array.slice(i, i + expectedSize));
  }
  return chunks;
};
var makeInstructions = (arr, instruction, cb) => {
  return chunkExact(arr, instruction).map((args) => {
    return cb(args);
  });
};
var segmentRegExp = /([astvzqmhlc])([^astvzqmhlc]*)/gi;
var numberRegExp = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi;
var parseValues = (args, instructionType) => {
  const numbers = args.match(numberRegExp);
  if (!numbers) {
    if (instructionType === "Z" || instructionType === "z") {
      return [];
    }
    throw new Error(`Malformed path data: ${instructionType} was expected to have numbers afterwards`);
  }
  const expectedArguments = length[instructionType];
  if (numbers.length % expectedArguments !== 0) {
    throw new Error(`Malformed path data: ${instructionType} was expected to have a multiple of ${expectedArguments} numbers, but got "${instructionType} ${numbers.join(" ")} instead"`);
  }
  return numbers.map(Number);
};
var parsePath = (path) => {
  if (!path) {
    throw new Error("No path provided");
  }
  const segments = path.match(segmentRegExp);
  if (!segments) {
    throw new Error(`No path elements found in string ${path}`);
  }
  return segments.map((segmentString) => {
    const command = segmentString.charAt(0);
    const args = parseValues(segmentString.substring(1), command);
    if (command === "M" && args.length > 2) {
      const segmentsArray = [];
      segmentsArray.push({
        type: command,
        x: args[0],
        y: args[1]
      });
      segmentsArray.push(...makeInstructions(args.slice(2), "L", (numbers) => ({
        type: "L",
        x: numbers[0],
        y: numbers[1]
      })));
      return segmentsArray;
    }
    if (command === "m" && args.length > 2) {
      const segmentsArray = [];
      segmentsArray.push({
        type: command,
        dx: args[0],
        dy: args[1]
      });
      segmentsArray.push(...makeInstructions(args.slice(2), "l", (numbers) => ({
        type: "l",
        dx: numbers[0],
        dy: numbers[1]
      })));
      return segmentsArray;
    }
    if (command === "Z" || command === "z") {
      return [
        {
          type: "Z"
        }
      ];
    }
    if (command === "A") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        rx: numbers[0],
        ry: numbers[1],
        xAxisRotation: numbers[2],
        largeArcFlag: numbers[3] === 1,
        sweepFlag: numbers[4] === 1,
        x: numbers[5],
        y: numbers[6]
      }));
    }
    if (command === "a") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        rx: numbers[0],
        ry: numbers[1],
        xAxisRotation: numbers[2],
        largeArcFlag: numbers[3] === 1,
        sweepFlag: numbers[4] === 1,
        dx: numbers[5],
        dy: numbers[6]
      }));
    }
    if (command === "C") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        cp1x: numbers[0],
        cp1y: numbers[1],
        cp2x: numbers[2],
        cp2y: numbers[3],
        x: numbers[4],
        y: numbers[5]
      }));
    }
    if (command === "c") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        cp1dx: numbers[0],
        cp1dy: numbers[1],
        cp2dx: numbers[2],
        cp2dy: numbers[3],
        dx: numbers[4],
        dy: numbers[5]
      }));
    }
    if (command === "S") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        cpx: numbers[0],
        cpy: numbers[1],
        x: numbers[2],
        y: numbers[3]
      }));
    }
    if (command === "s") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        cpdx: numbers[0],
        cpdy: numbers[1],
        dx: numbers[2],
        dy: numbers[3]
      }));
    }
    if (command === "H") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        x: numbers[0]
      }));
    }
    if (command === "h") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        dx: numbers[0]
      }));
    }
    if (command === "V") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        y: numbers[0]
      }));
    }
    if (command === "v") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        dy: numbers[0]
      }));
    }
    if (command === "L") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        x: numbers[0],
        y: numbers[1]
      }));
    }
    if (command === "M") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        x: numbers[0],
        y: numbers[1]
      }));
    }
    if (command === "m") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        dx: numbers[0],
        dy: numbers[1]
      }));
    }
    if (command === "l") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        dx: numbers[0],
        dy: numbers[1]
      }));
    }
    if (command === "Q") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        cpx: numbers[0],
        cpy: numbers[1],
        x: numbers[2],
        y: numbers[3]
      }));
    }
    if (command === "q") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        cpdx: numbers[0],
        cpdy: numbers[1],
        dx: numbers[2],
        dy: numbers[3]
      }));
    }
    if (command === "T") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        x: numbers[0],
        y: numbers[1]
      }));
    }
    if (command === "t") {
      return makeInstructions(args, command, (numbers) => ({
        type: command,
        dx: numbers[0],
        dy: numbers[1]
      }));
    }
    throw new Error(`Invalid path element ${segmentString}`);
  }, []).flat(1);
};
var TAU = Math.PI * 2;
var serializeInstruction = (instruction) => {
  if (instruction.type === "A") {
    return `A ${instruction.rx} ${instruction.ry} ${instruction.xAxisRotation} ${Number(instruction.largeArcFlag)} ${Number(instruction.sweepFlag)} ${instruction.x} ${instruction.y}`;
  }
  if (instruction.type === "a") {
    return `a ${instruction.rx} ${instruction.ry} ${instruction.xAxisRotation} ${Number(instruction.largeArcFlag)} ${Number(instruction.sweepFlag)} ${instruction.dx} ${instruction.dy}`;
  }
  if (instruction.type === "C") {
    return `C ${instruction.cp1x} ${instruction.cp1y} ${instruction.cp2x} ${instruction.cp2y} ${instruction.x} ${instruction.y}`;
  }
  if (instruction.type === "c") {
    return `c ${instruction.cp1dx} ${instruction.cp1dy} ${instruction.cp2dx} ${instruction.cp2dy} ${instruction.dx} ${instruction.dy}`;
  }
  if (instruction.type === "S") {
    return `S ${instruction.cpx} ${instruction.cpy} ${instruction.x} ${instruction.y}`;
  }
  if (instruction.type === "s") {
    return `s ${instruction.cpdx} ${instruction.cpdy} ${instruction.dx} ${instruction.dy}`;
  }
  if (instruction.type === "Q") {
    return `Q ${instruction.cpx} ${instruction.cpy} ${instruction.x} ${instruction.y}`;
  }
  if (instruction.type === "q") {
    return `q ${instruction.cpdx} ${instruction.cpdy} ${instruction.dx} ${instruction.dy}`;
  }
  if (instruction.type === "Z") {
    return "Z";
  }
  if (instruction.type === "H") {
    return `H ${instruction.x}`;
  }
  if (instruction.type === "h") {
    return `h ${instruction.dx}`;
  }
  if (instruction.type === "V") {
    return `V ${instruction.y}`;
  }
  if (instruction.type === "v") {
    return `v ${instruction.dy}`;
  }
  if (instruction.type === "L") {
    return `L ${instruction.x} ${instruction.y}`;
  }
  if (instruction.type === "l") {
    return `l ${instruction.dx} ${instruction.dy}`;
  }
  if (instruction.type === "M") {
    return `M ${instruction.x} ${instruction.y}`;
  }
  if (instruction.type === "m") {
    return `m ${instruction.dx} ${instruction.dy}`;
  }
  if (instruction.type === "T") {
    return `T ${instruction.x} ${instruction.y}`;
  }
  if (instruction.type === "t") {
    return `t ${instruction.dx} ${instruction.dy}`;
  }
  throw new Error(`Unknown instruction type: ${instruction.type}`);
};
var serializeInstructions = (path) => {
  return path.map((p) => {
    return serializeInstruction(p);
  }).join(" ");
};
var translateSegments = (segments, x, y) => {
  return segments.map((segment) => {
    if (segment.type === "a" || segment.type === "c" || segment.type === "v" || segment.type === "s" || segment.type === "h" || segment.type === "l" || segment.type === "m" || segment.type === "q" || segment.type === "t") {
      return segment;
    }
    if (segment.type === "V") {
      return {
        type: "V",
        y: segment.y + y
      };
    }
    if (segment.type === "H") {
      return {
        type: "H",
        x: segment.x + x
      };
    }
    if (segment.type === "A") {
      return {
        type: "A",
        rx: segment.rx,
        ry: segment.ry,
        largeArcFlag: segment.largeArcFlag,
        sweepFlag: segment.sweepFlag,
        xAxisRotation: segment.xAxisRotation,
        x: segment.x + x,
        y: segment.y + y
      };
    }
    if (segment.type === "Z") {
      return segment;
    }
    if (segment.type === "C") {
      return {
        type: "C",
        cp1x: segment.cp1x + x,
        cp1y: segment.cp1y + y,
        cp2x: segment.cp2x + x,
        cp2y: segment.cp2y + y,
        x: segment.x + x,
        y: segment.y + y
      };
    }
    if (segment.type === "Q") {
      return {
        type: "Q",
        cpx: segment.cpx + x,
        cpy: segment.cpy + y,
        x: segment.x + x,
        y: segment.y + y
      };
    }
    if (segment.type === "S") {
      return {
        type: "S",
        cpx: segment.cpx + x,
        cpy: segment.cpy + y,
        x: segment.x + x,
        y: segment.y + y
      };
    }
    if (segment.type === "T") {
      return {
        type: "T",
        x: segment.x + x,
        y: segment.y + y
      };
    }
    if (segment.type === "L") {
      return {
        type: "L",
        x: segment.x + x,
        y: segment.y + y
      };
    }
    if (segment.type === "M") {
      return {
        type: "M",
        x: segment.x + x,
        y: segment.y + y
      };
    }
    throw new Error(`Unknown segment type: ${segment.type}`);
  });
};
var translatePath = (path, x, y) => {
  return serializeInstructions(translateSegments(parsePath(path), x, y));
};

// node_modules/@remotion/shapes/dist/esm/index.mjs
var import_react = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var makeCircle = ({ radius }) => {
  const instructions = [
    {
      type: "M",
      x: radius,
      y: 0
    },
    {
      type: "a",
      rx: radius,
      ry: radius,
      xAxisRotation: 0,
      largeArcFlag: true,
      sweepFlag: true,
      dx: 0,
      dy: radius * 2
    },
    {
      type: "a",
      rx: radius,
      ry: radius,
      xAxisRotation: 0,
      largeArcFlag: true,
      sweepFlag: true,
      dx: 0,
      dy: -radius * 2
    },
    {
      type: "Z"
    }
  ];
  const path = serializeInstructions(instructions);
  return {
    height: radius * 2,
    width: radius * 2,
    path,
    instructions,
    transformOrigin: `${radius} ${radius}`
  };
};
var getCoord = ({
  counterClockwise,
  actualProgress,
  rotation,
  radius,
  coord
}) => {
  const factor = counterClockwise ? -1 : 1;
  const val = Math[coord === "x" ? "cos" : "sin"](factor * actualProgress * Math.PI * 2 + Math.PI * 1.5 + rotation) * radius + radius;
  const rounded = Math.round(val * 1e5) / 1e5;
  return rounded;
};
var makePie = ({
  progress,
  radius,
  closePath = true,
  counterClockwise = false,
  rotation = 0
}) => {
  const actualProgress = Math.min(Math.max(progress, 0), 1);
  const endAngleX = getCoord({
    actualProgress,
    coord: "x",
    counterClockwise,
    radius,
    rotation
  });
  const endAngleY = getCoord({
    actualProgress,
    coord: "y",
    counterClockwise,
    radius,
    rotation
  });
  const start = {
    x: getCoord({
      actualProgress: 0,
      coord: "x",
      counterClockwise,
      radius,
      rotation
    }),
    y: getCoord({
      actualProgress: 0,
      coord: "y",
      counterClockwise,
      radius,
      rotation
    })
  };
  const end = { x: endAngleX, y: endAngleY };
  const instructions = [
    {
      type: "M",
      ...start
    },
    {
      type: "A",
      rx: radius,
      ry: radius,
      xAxisRotation: 0,
      largeArcFlag: false,
      sweepFlag: !counterClockwise,
      x: actualProgress <= 0.5 ? endAngleX : getCoord({
        actualProgress: 0.5,
        coord: "x",
        counterClockwise,
        radius,
        rotation
      }),
      y: actualProgress <= 0.5 ? endAngleY : getCoord({
        actualProgress: 0.5,
        coord: "y",
        counterClockwise,
        radius,
        rotation
      })
    },
    actualProgress > 0.5 ? {
      type: "A",
      rx: radius,
      ry: radius,
      xAxisRotation: 0,
      largeArcFlag: false,
      sweepFlag: !counterClockwise,
      ...end
    } : null,
    actualProgress > 0 && actualProgress < 1 && closePath ? {
      type: "L",
      x: radius,
      y: radius
    } : null,
    closePath ? {
      type: "Z"
    } : null
  ].filter(Boolean);
  const path = serializeInstructions(instructions);
  return {
    height: radius * 2,
    width: radius * 2,
    path,
    instructions,
    transformOrigin: `${radius} ${radius}`
  };
};

export {
  translatePath,
  makeCircle,
  makePie
};
//# sourceMappingURL=chunk-JWAYUXLS.js.map
